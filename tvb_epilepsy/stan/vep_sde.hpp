// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace vep_sde_model_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "/Users/dionperd/VEPtools/git/tvb-epilepsy/tvb_epilepsy/stan/vep_sde.stan");
    reader.add_event(395, 395, "end", "/Users/dionperd/VEPtools/git/tvb-epilepsy/tvb_epilepsy/stan/vep_sde.stan");
    return reader;
}

template <bool propto, typename T0__, typename T2__>
typename boost::math::tools::promote_args<T0__, T2__>::type
sample_lpdf(const T0__& x,
                const int& pdf,
                const std::vector<T2__>& shape, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 4;
        if (as_bool(logical_eq(pdf,1))) {

            current_statement_begin__ = 6;
            return stan::math::promote_scalar<fun_return_scalar_t__>(normal_log(x,get_base1(shape,1,"shape",1),get_base1(shape,2,"shape",1)));
        } else if (as_bool(logical_eq(pdf,2))) {

            current_statement_begin__ = 9;
            return stan::math::promote_scalar<fun_return_scalar_t__>(gamma_log(x,get_base1(shape,1,"shape",1),(1.0 / get_base1(shape,2,"shape",1))));
        } else if (as_bool(logical_eq(pdf,3))) {

            current_statement_begin__ = 12;
            return stan::math::promote_scalar<fun_return_scalar_t__>(lognormal_log(x,get_base1(shape,1,"shape",1),get_base1(shape,2,"shape",1)));
        } else if (as_bool(logical_eq(pdf,4))) {

            current_statement_begin__ = 15;
            return stan::math::promote_scalar<fun_return_scalar_t__>(exponential_log(x,get_base1(shape,1,"shape",1)));
        } else {

            current_statement_begin__ = 23;
            return stan::math::promote_scalar<fun_return_scalar_t__>(uniform_log(x,get_base1(shape,1,"shape",1),get_base1(shape,2,"shape",1)));
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T2__>
typename boost::math::tools::promote_args<T0__, T2__>::type
sample_lpdf(const T0__& x,
                const int& pdf,
                const std::vector<T2__>& shape, std::ostream* pstream__) {
    return sample_lpdf<false>(x,pdf,shape, pstream__);
}


struct sample_lpdf_functor__ {
    template <bool propto, typename T0__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T2__>::type
    operator()(const T0__& x,
                const int& pdf,
                const std::vector<T2__>& shape, std::ostream* pstream__) const {
        return sample_lpdf(x, pdf, shape, pstream__);
    }
};

template <bool propto, typename T0__, typename T2__>
typename boost::math::tools::promote_args<T0__, T2__>::type
sample_from_stdnormal_lpdf(const T0__& x,
                               const int& pdf,
                               const std::vector<T2__>& shape, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T2__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 28;
        fun_scalar_t__ n01;
        (void) n01;  // dummy to suppress unused var warning

        stan::math::initialize(n01, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(n01,DUMMY_VAR__);


        current_statement_begin__ = 29;
        if (as_bool(logical_eq(pdf,1))) {

            current_statement_begin__ = 31;
            stan::math::assign(n01, normal_log(x,0.0,1.0));
            current_statement_begin__ = 32;
            return stan::math::promote_scalar<fun_return_scalar_t__>((get_base1(shape,1,"shape",1) + (get_base1(shape,2,"shape",1) * n01)));
        } else if (as_bool(logical_eq(pdf,2))) {

            current_statement_begin__ = 35;
            return stan::math::promote_scalar<fun_return_scalar_t__>(gamma_log(x,get_base1(shape,1,"shape",1),(1.0 / get_base1(shape,2,"shape",1))));
        } else if (as_bool(logical_eq(pdf,3))) {

            current_statement_begin__ = 38;
            stan::math::assign(n01, normal_log(x,0.0,1.0));
            current_statement_begin__ = 39;
            return stan::math::promote_scalar<fun_return_scalar_t__>(exp((get_base1(shape,1,"shape",1) + (get_base1(shape,2,"shape",1) * n01))));
        } else if (as_bool(logical_eq(pdf,4))) {

            current_statement_begin__ = 42;
            return stan::math::promote_scalar<fun_return_scalar_t__>(exponential_log(x,get_base1(shape,1,"shape",1)));
        } else {

            current_statement_begin__ = 50;
            return stan::math::promote_scalar<fun_return_scalar_t__>(uniform_log(x,get_base1(shape,1,"shape",1),get_base1(shape,2,"shape",1)));
        }
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T2__>
typename boost::math::tools::promote_args<T0__, T2__>::type
sample_from_stdnormal_lpdf(const T0__& x,
                               const int& pdf,
                               const std::vector<T2__>& shape, std::ostream* pstream__) {
    return sample_from_stdnormal_lpdf<false>(x,pdf,shape, pstream__);
}


struct sample_from_stdnormal_lpdf_functor__ {
    template <bool propto, typename T0__, typename T2__>
        typename boost::math::tools::promote_args<T0__, T2__>::type
    operator()(const T0__& x,
                               const int& pdf,
                               const std::vector<T2__>& shape, std::ostream* pstream__) const {
        return sample_from_stdnormal_lpdf(x, pdf, shape, pstream__);
    }
};

template <typename T1__, typename T2__, typename T3__>
Eigen::Matrix<typename boost::math::tools::promote_args<T1__, T2__, T3__>::type, 1,Eigen::Dynamic>
ode_step(const int& nx,
             const Eigen::Matrix<T1__, 1,Eigen::Dynamic>& x,
             const Eigen::Matrix<T2__, 1,Eigen::Dynamic>& df,
             const T3__& dt, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T1__, T2__, T3__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 55;
        validate_non_negative_index("x_next", "nx", nx);
        Eigen::Matrix<fun_scalar_t__,1,Eigen::Dynamic>  x_next(static_cast<Eigen::VectorXd::Index>(nx));
        (void) x_next;  // dummy to suppress unused var warning

        stan::math::initialize(x_next, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(x_next,DUMMY_VAR__);
        stan::math::assign(x_next,add(x,multiply(df,dt)));


        current_statement_begin__ = 56;
        return stan::math::promote_scalar<fun_return_scalar_t__>(x_next);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct ode_step_functor__ {
    template <typename T1__, typename T2__, typename T3__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T1__, T2__, T3__>::type, 1,Eigen::Dynamic>
    operator()(const int& nx,
             const Eigen::Matrix<T1__, 1,Eigen::Dynamic>& x,
             const Eigen::Matrix<T2__, 1,Eigen::Dynamic>& df,
             const T3__& dt, std::ostream* pstream__) const {
        return ode_step(nx, x, df, dt, pstream__);
    }
};

template <typename T1__, typename T2__, typename T3__, typename T4__>
Eigen::Matrix<typename boost::math::tools::promote_args<T1__, T2__, T3__, T4__>::type, 1,Eigen::Dynamic>
sde_step(const int& nx,
             const Eigen::Matrix<T1__, 1,Eigen::Dynamic>& x,
             const Eigen::Matrix<T2__, 1,Eigen::Dynamic>& df,
             const T3__& dt,
             const Eigen::Matrix<T4__, 1,Eigen::Dynamic>& dWtsqrtdt, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T1__, T2__, T3__, T4__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 60;
        validate_non_negative_index("x_next", "nx", nx);
        Eigen::Matrix<fun_scalar_t__,1,Eigen::Dynamic>  x_next(static_cast<Eigen::VectorXd::Index>(nx));
        (void) x_next;  // dummy to suppress unused var warning

        stan::math::initialize(x_next, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(x_next,DUMMY_VAR__);
        stan::math::assign(x_next,add(add(x,multiply(df,dt)),dWtsqrtdt));


        current_statement_begin__ = 61;
        return stan::math::promote_scalar<fun_return_scalar_t__>(x_next);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct sde_step_functor__ {
    template <typename T1__, typename T2__, typename T3__, typename T4__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T1__, T2__, T3__, T4__>::type, 1,Eigen::Dynamic>
    operator()(const int& nx,
             const Eigen::Matrix<T1__, 1,Eigen::Dynamic>& x,
             const Eigen::Matrix<T2__, 1,Eigen::Dynamic>& df,
             const T3__& dt,
             const Eigen::Matrix<T4__, 1,Eigen::Dynamic>& dWtsqrtdt, std::ostream* pstream__) const {
        return sde_step(nx, x, df, dt, dWtsqrtdt, pstream__);
    }
};

template <typename T2__, typename T3__>
Eigen::Matrix<typename boost::math::tools::promote_args<T2__, T3__>::type, Eigen::Dynamic,Eigen::Dynamic>
vector_differencing(const int& ni,
                        const int& nj,
                        const Eigen::Matrix<T2__, 1,Eigen::Dynamic>& xi,
                        const Eigen::Matrix<T3__, 1,Eigen::Dynamic>& xj, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T2__, T3__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 65;
        validate_non_negative_index("Dji", "nj", nj);
        validate_non_negative_index("Dji", "ni", ni);
        Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  Dji(static_cast<Eigen::VectorXd::Index>(nj),static_cast<Eigen::VectorXd::Index>(ni));
        (void) Dji;  // dummy to suppress unused var warning

        stan::math::initialize(Dji, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(Dji,DUMMY_VAR__);


        current_statement_begin__ = 66;
        for (int j = 1; j <= nj; ++j) {

            current_statement_begin__ = 67;
            stan::math::assign(get_base1_lhs(Dji,j,"Dji",1), subtract(xi,get_base1(xj,j,"xj",1)));
        }
        current_statement_begin__ = 69;
        return stan::math::promote_scalar<fun_return_scalar_t__>(transpose(Dji));
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct vector_differencing_functor__ {
    template <typename T2__, typename T3__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T2__, T3__>::type, Eigen::Dynamic,Eigen::Dynamic>
    operator()(const int& ni,
                        const int& nj,
                        const Eigen::Matrix<T2__, 1,Eigen::Dynamic>& xi,
                        const Eigen::Matrix<T3__, 1,Eigen::Dynamic>& xj, std::ostream* pstream__) const {
        return vector_differencing(ni, nj, xi, xj, pstream__);
    }
};

template <typename T2__, typename T3__, typename T4__>
Eigen::Matrix<typename boost::math::tools::promote_args<T2__, T3__, T4__>::type, 1,Eigen::Dynamic>
calc_coupling(const int& ni,
                  const int& nj,
                  const Eigen::Matrix<T2__, 1,Eigen::Dynamic>& xi,
                  const Eigen::Matrix<T3__, 1,Eigen::Dynamic>& xj,
                  const Eigen::Matrix<T4__, Eigen::Dynamic,Eigen::Dynamic>& MC, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T2__, T3__, T4__>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 73;
        validate_non_negative_index("Dij", "ni", ni);
        validate_non_negative_index("Dij", "nj", nj);
        Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,Eigen::Dynamic>  Dij(static_cast<Eigen::VectorXd::Index>(ni),static_cast<Eigen::VectorXd::Index>(nj));
        (void) Dij;  // dummy to suppress unused var warning

        stan::math::initialize(Dij, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(Dij,DUMMY_VAR__);
        stan::math::assign(Dij,vector_differencing(ni,nj,xi,xj, pstream__));
        current_statement_begin__ = 74;
        validate_non_negative_index("coupling", "ni", ni);
        Eigen::Matrix<fun_scalar_t__,1,Eigen::Dynamic>  coupling(static_cast<Eigen::VectorXd::Index>(ni));
        (void) coupling;  // dummy to suppress unused var warning

        stan::math::initialize(coupling, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(coupling,DUMMY_VAR__);
        stan::math::assign(coupling,to_row_vector(rows_dot_product(MC,Dij)));


        current_statement_begin__ = 75;
        return stan::math::promote_scalar<fun_return_scalar_t__>(coupling);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct calc_coupling_functor__ {
    template <typename T2__, typename T3__, typename T4__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T2__, T3__, T4__>::type, 1,Eigen::Dynamic>
    operator()(const int& ni,
                  const int& nj,
                  const Eigen::Matrix<T2__, 1,Eigen::Dynamic>& xi,
                  const Eigen::Matrix<T3__, 1,Eigen::Dynamic>& xj,
                  const Eigen::Matrix<T4__, Eigen::Dynamic,Eigen::Dynamic>& MC, std::ostream* pstream__) const {
        return calc_coupling(ni, nj, xi, xj, MC, pstream__);
    }
};

template <typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
Eigen::Matrix<typename boost::math::tools::promote_args<T1__, T2__, T3__, T4__, typename boost::math::tools::promote_args<T5__, T6__, T7__, T8__, typename boost::math::tools::promote_args<T9__>::type>::type>::type, 1,Eigen::Dynamic>
EpileptorDP2D_fun_x1(const int& nn,
                         const Eigen::Matrix<T1__, 1,Eigen::Dynamic>& x1,
                         const Eigen::Matrix<T2__, 1,Eigen::Dynamic>& z,
                         const T3__& yc,
                         const T4__& Iext1,
                         const T5__& a,
                         const T6__& db,
                         const T7__& d,
                         const T8__& slope,
                         const T9__& tau1, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T1__, T2__, T3__, T4__, typename boost::math::tools::promote_args<T5__, T6__, T7__, T8__, typename boost::math::tools::promote_args<T9__>::type>::type>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 80;
        validate_non_negative_index("constants", "nn", nn);
        Eigen::Matrix<fun_scalar_t__,1,Eigen::Dynamic>  constants(static_cast<Eigen::VectorXd::Index>(nn));
        (void) constants;  // dummy to suppress unused var warning

        stan::math::initialize(constants, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(constants,DUMMY_VAR__);
        stan::math::assign(constants,rep_row_vector((Iext1 + yc),nn));
        current_statement_begin__ = 81;
        validate_non_negative_index("fx1", "nn", nn);
        Eigen::Matrix<fun_scalar_t__,1,Eigen::Dynamic>  fx1(static_cast<Eigen::VectorXd::Index>(nn));
        (void) fx1;  // dummy to suppress unused var warning

        stan::math::initialize(fx1, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(fx1,DUMMY_VAR__);


        current_statement_begin__ = 82;
        for (int ii = 1; ii <= nn; ++ii) {

            current_statement_begin__ = 84;
            if (as_bool(logical_lte(get_base1(x1,ii,"x1",1),0.0))) {

                current_statement_begin__ = 86;
                stan::math::assign(get_base1_lhs(fx1,ii,"fx1",1), (((a * get_base1(x1,ii,"x1",1)) * get_base1(x1,ii,"x1",1)) + (db * get_base1(x1,ii,"x1",1))));
            } else {

                current_statement_begin__ = 89;
                stan::math::assign(get_base1_lhs(fx1,ii,"fx1",1), (get_base1(z,ii,"z",1) - 4.0));
                current_statement_begin__ = 90;
                stan::math::assign(get_base1_lhs(fx1,ii,"fx1",1), (((d * get_base1(x1,ii,"x1",1)) - ((0.59999999999999998 * get_base1(fx1,ii,"fx1",1)) * get_base1(fx1,ii,"fx1",1))) - slope));
            }
        }
        current_statement_begin__ = 94;
        stan::math::assign(fx1, multiply(tau1,subtract(subtract(constants,z),elt_multiply(fx1,x1))));
        current_statement_begin__ = 95;
        return stan::math::promote_scalar<fun_return_scalar_t__>(fx1);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct EpileptorDP2D_fun_x1_functor__ {
    template <typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T1__, T2__, T3__, T4__, typename boost::math::tools::promote_args<T5__, T6__, T7__, T8__, typename boost::math::tools::promote_args<T9__>::type>::type>::type, 1,Eigen::Dynamic>
    operator()(const int& nn,
                         const Eigen::Matrix<T1__, 1,Eigen::Dynamic>& x1,
                         const Eigen::Matrix<T2__, 1,Eigen::Dynamic>& z,
                         const T3__& yc,
                         const T4__& Iext1,
                         const T5__& a,
                         const T6__& db,
                         const T7__& d,
                         const T8__& slope,
                         const T9__& tau1, std::ostream* pstream__) const {
        return EpileptorDP2D_fun_x1(nn, x1, z, yc, Iext1, a, db, d, slope, tau1, pstream__);
    }
};

template <typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__>
Eigen::Matrix<typename boost::math::tools::promote_args<T1__, T2__, T3__, T4__, typename boost::math::tools::promote_args<T5__, T6__>::type>::type, 1,Eigen::Dynamic>
EpileptorDP2D_fun_z_lin(const int& nn,
                            const Eigen::Matrix<T1__, 1,Eigen::Dynamic>& x1,
                            const Eigen::Matrix<T2__, 1,Eigen::Dynamic>& z,
                            const Eigen::Matrix<T3__, 1,Eigen::Dynamic>& x0,
                            const Eigen::Matrix<T4__, 1,Eigen::Dynamic>& coupling,
                            const T5__& tau0,
                            const T6__& tau1, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T1__, T2__, T3__, T4__, typename boost::math::tools::promote_args<T5__, T6__>::type>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 102;
        validate_non_negative_index("fz", "nn", nn);
        Eigen::Matrix<fun_scalar_t__,1,Eigen::Dynamic>  fz(static_cast<Eigen::VectorXd::Index>(nn));
        (void) fz;  // dummy to suppress unused var warning

        stan::math::initialize(fz, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(fz,DUMMY_VAR__);
        stan::math::assign(fz,subtract(subtract(multiply(4.0,subtract(x1,x0)),z),coupling));


        current_statement_begin__ = 103;
        for (int ii = 1; ii <= nn; ++ii) {

            current_statement_begin__ = 104;
            if (as_bool(logical_lt(get_base1(z,ii,"z",1),0.0))) {

                current_statement_begin__ = 106;
                stan::math::assign(get_base1_lhs(fz,ii,"fz",1), (get_base1(fz,ii,"fz",1) - (((((((0.10000000000000001 * get_base1(z,ii,"z",1)) * get_base1(z,ii,"z",1)) * get_base1(z,ii,"z",1)) * get_base1(z,ii,"z",1)) * get_base1(z,ii,"z",1)) * get_base1(z,ii,"z",1)) * get_base1(z,ii,"z",1))));
            }
        }
        current_statement_begin__ = 109;
        stan::math::assign(fz, divide(multiply(tau1,fz),tau0));
        current_statement_begin__ = 110;
        return stan::math::promote_scalar<fun_return_scalar_t__>(fz);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct EpileptorDP2D_fun_z_lin_functor__ {
    template <typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T1__, T2__, T3__, T4__, typename boost::math::tools::promote_args<T5__, T6__>::type>::type, 1,Eigen::Dynamic>
    operator()(const int& nn,
                            const Eigen::Matrix<T1__, 1,Eigen::Dynamic>& x1,
                            const Eigen::Matrix<T2__, 1,Eigen::Dynamic>& z,
                            const Eigen::Matrix<T3__, 1,Eigen::Dynamic>& x0,
                            const Eigen::Matrix<T4__, 1,Eigen::Dynamic>& coupling,
                            const T5__& tau0,
                            const T6__& tau1, std::ostream* pstream__) const {
        return EpileptorDP2D_fun_z_lin(nn, x1, z, x0, coupling, tau0, tau1, pstream__);
    }
};

class vep_sde_model : public prob_grad {
private:
    int SIMULATE;
    int DEBUG;
    int n_regions;
    int n_times;
    int n_signals;
    int n_active_regions;
    int n_nonactive_regions;
    int n_connections;
    vector<int> active_regions;
    vector<int> nonactive_regions;
    double a;
    double b;
    double d;
    double yc;
    double Iext1;
    double slope;
    double x0cr;
    double rx0;
    double x1eq_lo;
    double x1eq_hi;
    row_vector_d x1eq0;
    double x1init_lo;
    double x1init_hi;
    double zinit_lo;
    double zinit_hi;
    double tau1_lo;
    double tau1_hi;
    double tau1_loc;
    double tau1_scale;
    vector<double> tau1_p;
    int tau1_pdf;
    double tau0_lo;
    double tau0_hi;
    double tau0_loc;
    double tau0_scale;
    vector<double> tau0_p;
    int tau0_pdf;
    double K_lo;
    double K_hi;
    double K_loc;
    double K_scale;
    vector<double> K_p;
    int K_pdf;
    matrix_d SC;
    double MC_split_lo;
    double MC_split_hi;
    row_vector_d MC_split_loc;
    row_vector_d MC_split_scale;
    double MC_scale;
    double dt;
    double sig_eq;
    double sig_init;
    double sig_lo;
    double sig_hi;
    double sig_loc;
    double sig_scale;
    vector<double> sig_p;
    int sig_pdf;
    int observation_model;
    matrix_d mixing;
    vector<row_vector_d> signals;
    double eps_lo;
    double eps_hi;
    double eps_loc;
    double eps_scale;
    vector<double> eps_p;
    int eps_pdf;
    double scale_signal_lo;
    double scale_signal_hi;
    double scale_signal_loc;
    double scale_signal_scale;
    vector<double> scale_signal_p;
    int scale_signal_pdf;
    double offset_signal_lo;
    double offset_signal_hi;
    double offset_signal_loc;
    double offset_signal_scale;
    double db;
    double sqrtdt;
    row_vector_d zeros;
    double tau1_star_lo;
    double tau1_star_hi;
    double tau0_star_lo;
    double tau0_star_hi;
    double K_star_lo;
    double K_star_hi;
    double sig_star_lo;
    double sig_star_hi;
    double eps_star_lo;
    double eps_star_hi;
    double scale_signal_star_lo;
    double scale_signal_star_hi;
public:
    vep_sde_model(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    vep_sde_model(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "vep_sde_model_namespace::vep_sde_model";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            current_statement_begin__ = 118;
            context__.validate_dims("data initialization", "SIMULATE", "int", context__.to_vec());
            SIMULATE = int(0);
            vals_i__ = context__.vals_i("SIMULATE");
            pos__ = 0;
            SIMULATE = vals_i__[pos__++];
            current_statement_begin__ = 119;
            context__.validate_dims("data initialization", "DEBUG", "int", context__.to_vec());
            DEBUG = int(0);
            vals_i__ = context__.vals_i("DEBUG");
            pos__ = 0;
            DEBUG = vals_i__[pos__++];
            current_statement_begin__ = 121;
            context__.validate_dims("data initialization", "n_regions", "int", context__.to_vec());
            n_regions = int(0);
            vals_i__ = context__.vals_i("n_regions");
            pos__ = 0;
            n_regions = vals_i__[pos__++];
            current_statement_begin__ = 122;
            context__.validate_dims("data initialization", "n_times", "int", context__.to_vec());
            n_times = int(0);
            vals_i__ = context__.vals_i("n_times");
            pos__ = 0;
            n_times = vals_i__[pos__++];
            current_statement_begin__ = 123;
            context__.validate_dims("data initialization", "n_signals", "int", context__.to_vec());
            n_signals = int(0);
            vals_i__ = context__.vals_i("n_signals");
            pos__ = 0;
            n_signals = vals_i__[pos__++];
            current_statement_begin__ = 124;
            context__.validate_dims("data initialization", "n_active_regions", "int", context__.to_vec());
            n_active_regions = int(0);
            vals_i__ = context__.vals_i("n_active_regions");
            pos__ = 0;
            n_active_regions = vals_i__[pos__++];
            current_statement_begin__ = 125;
            context__.validate_dims("data initialization", "n_nonactive_regions", "int", context__.to_vec());
            n_nonactive_regions = int(0);
            vals_i__ = context__.vals_i("n_nonactive_regions");
            pos__ = 0;
            n_nonactive_regions = vals_i__[pos__++];
            current_statement_begin__ = 126;
            context__.validate_dims("data initialization", "n_connections", "int", context__.to_vec());
            n_connections = int(0);
            vals_i__ = context__.vals_i("n_connections");
            pos__ = 0;
            n_connections = vals_i__[pos__++];
            current_statement_begin__ = 129;
            validate_non_negative_index("active_regions", "n_active_regions", n_active_regions);
            context__.validate_dims("data initialization", "active_regions", "int", context__.to_vec(n_active_regions));
            validate_non_negative_index("active_regions", "n_active_regions", n_active_regions);
            active_regions = std::vector<int>(n_active_regions,int(0));
            vals_i__ = context__.vals_i("active_regions");
            pos__ = 0;
            size_t active_regions_limit_0__ = n_active_regions;
            for (size_t i_0__ = 0; i_0__ < active_regions_limit_0__; ++i_0__) {
                active_regions[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 130;
            validate_non_negative_index("nonactive_regions", "n_nonactive_regions", n_nonactive_regions);
            context__.validate_dims("data initialization", "nonactive_regions", "int", context__.to_vec(n_nonactive_regions));
            validate_non_negative_index("nonactive_regions", "n_nonactive_regions", n_nonactive_regions);
            nonactive_regions = std::vector<int>(n_nonactive_regions,int(0));
            vals_i__ = context__.vals_i("nonactive_regions");
            pos__ = 0;
            size_t nonactive_regions_limit_0__ = n_nonactive_regions;
            for (size_t i_0__ = 0; i_0__ < nonactive_regions_limit_0__; ++i_0__) {
                nonactive_regions[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 147;
            context__.validate_dims("data initialization", "a", "double", context__.to_vec());
            a = double(0);
            vals_r__ = context__.vals_r("a");
            pos__ = 0;
            a = vals_r__[pos__++];
            current_statement_begin__ = 148;
            context__.validate_dims("data initialization", "b", "double", context__.to_vec());
            b = double(0);
            vals_r__ = context__.vals_r("b");
            pos__ = 0;
            b = vals_r__[pos__++];
            current_statement_begin__ = 149;
            context__.validate_dims("data initialization", "d", "double", context__.to_vec());
            d = double(0);
            vals_r__ = context__.vals_r("d");
            pos__ = 0;
            d = vals_r__[pos__++];
            current_statement_begin__ = 150;
            context__.validate_dims("data initialization", "yc", "double", context__.to_vec());
            yc = double(0);
            vals_r__ = context__.vals_r("yc");
            pos__ = 0;
            yc = vals_r__[pos__++];
            current_statement_begin__ = 151;
            context__.validate_dims("data initialization", "Iext1", "double", context__.to_vec());
            Iext1 = double(0);
            vals_r__ = context__.vals_r("Iext1");
            pos__ = 0;
            Iext1 = vals_r__[pos__++];
            current_statement_begin__ = 152;
            context__.validate_dims("data initialization", "slope", "double", context__.to_vec());
            slope = double(0);
            vals_r__ = context__.vals_r("slope");
            pos__ = 0;
            slope = vals_r__[pos__++];
            current_statement_begin__ = 153;
            context__.validate_dims("data initialization", "x0cr", "double", context__.to_vec());
            x0cr = double(0);
            vals_r__ = context__.vals_r("x0cr");
            pos__ = 0;
            x0cr = vals_r__[pos__++];
            current_statement_begin__ = 154;
            context__.validate_dims("data initialization", "rx0", "double", context__.to_vec());
            rx0 = double(0);
            vals_r__ = context__.vals_r("rx0");
            pos__ = 0;
            rx0 = vals_r__[pos__++];
            current_statement_begin__ = 158;
            context__.validate_dims("data initialization", "x1eq_lo", "double", context__.to_vec());
            x1eq_lo = double(0);
            vals_r__ = context__.vals_r("x1eq_lo");
            pos__ = 0;
            x1eq_lo = vals_r__[pos__++];
            current_statement_begin__ = 159;
            context__.validate_dims("data initialization", "x1eq_hi", "double", context__.to_vec());
            x1eq_hi = double(0);
            vals_r__ = context__.vals_r("x1eq_hi");
            pos__ = 0;
            x1eq_hi = vals_r__[pos__++];
            current_statement_begin__ = 160;
            validate_non_negative_index("x1eq0", "n_regions", n_regions);
            context__.validate_dims("data initialization", "x1eq0", "row_vector_d", context__.to_vec(n_regions));
            validate_non_negative_index("x1eq0", "n_regions", n_regions);
            x1eq0 = row_vector_d(static_cast<Eigen::VectorXd::Index>(n_regions));
            vals_r__ = context__.vals_r("x1eq0");
            pos__ = 0;
            size_t x1eq0_i_vec_lim__ = n_regions;
            for (size_t i_vec__ = 0; i_vec__ < x1eq0_i_vec_lim__; ++i_vec__) {
                x1eq0[i_vec__] = vals_r__[pos__++];
            }
            current_statement_begin__ = 164;
            context__.validate_dims("data initialization", "x1init_lo", "double", context__.to_vec());
            x1init_lo = double(0);
            vals_r__ = context__.vals_r("x1init_lo");
            pos__ = 0;
            x1init_lo = vals_r__[pos__++];
            current_statement_begin__ = 165;
            context__.validate_dims("data initialization", "x1init_hi", "double", context__.to_vec());
            x1init_hi = double(0);
            vals_r__ = context__.vals_r("x1init_hi");
            pos__ = 0;
            x1init_hi = vals_r__[pos__++];
            current_statement_begin__ = 167;
            context__.validate_dims("data initialization", "zinit_lo", "double", context__.to_vec());
            zinit_lo = double(0);
            vals_r__ = context__.vals_r("zinit_lo");
            pos__ = 0;
            zinit_lo = vals_r__[pos__++];
            current_statement_begin__ = 168;
            context__.validate_dims("data initialization", "zinit_hi", "double", context__.to_vec());
            zinit_hi = double(0);
            vals_r__ = context__.vals_r("zinit_hi");
            pos__ = 0;
            zinit_hi = vals_r__[pos__++];
            current_statement_begin__ = 170;
            context__.validate_dims("data initialization", "tau1_lo", "double", context__.to_vec());
            tau1_lo = double(0);
            vals_r__ = context__.vals_r("tau1_lo");
            pos__ = 0;
            tau1_lo = vals_r__[pos__++];
            current_statement_begin__ = 171;
            context__.validate_dims("data initialization", "tau1_hi", "double", context__.to_vec());
            tau1_hi = double(0);
            vals_r__ = context__.vals_r("tau1_hi");
            pos__ = 0;
            tau1_hi = vals_r__[pos__++];
            current_statement_begin__ = 172;
            context__.validate_dims("data initialization", "tau1_loc", "double", context__.to_vec());
            tau1_loc = double(0);
            vals_r__ = context__.vals_r("tau1_loc");
            pos__ = 0;
            tau1_loc = vals_r__[pos__++];
            current_statement_begin__ = 173;
            context__.validate_dims("data initialization", "tau1_scale", "double", context__.to_vec());
            tau1_scale = double(0);
            vals_r__ = context__.vals_r("tau1_scale");
            pos__ = 0;
            tau1_scale = vals_r__[pos__++];
            current_statement_begin__ = 174;
            validate_non_negative_index("tau1_p", "2", 2);
            context__.validate_dims("data initialization", "tau1_p", "double", context__.to_vec(2));
            validate_non_negative_index("tau1_p", "2", 2);
            tau1_p = std::vector<double>(2,double(0));
            vals_r__ = context__.vals_r("tau1_p");
            pos__ = 0;
            size_t tau1_p_limit_0__ = 2;
            for (size_t i_0__ = 0; i_0__ < tau1_p_limit_0__; ++i_0__) {
                tau1_p[i_0__] = vals_r__[pos__++];
            }
            current_statement_begin__ = 175;
            context__.validate_dims("data initialization", "tau1_pdf", "int", context__.to_vec());
            tau1_pdf = int(0);
            vals_i__ = context__.vals_i("tau1_pdf");
            pos__ = 0;
            tau1_pdf = vals_i__[pos__++];
            current_statement_begin__ = 177;
            context__.validate_dims("data initialization", "tau0_lo", "double", context__.to_vec());
            tau0_lo = double(0);
            vals_r__ = context__.vals_r("tau0_lo");
            pos__ = 0;
            tau0_lo = vals_r__[pos__++];
            current_statement_begin__ = 178;
            context__.validate_dims("data initialization", "tau0_hi", "double", context__.to_vec());
            tau0_hi = double(0);
            vals_r__ = context__.vals_r("tau0_hi");
            pos__ = 0;
            tau0_hi = vals_r__[pos__++];
            current_statement_begin__ = 179;
            context__.validate_dims("data initialization", "tau0_loc", "double", context__.to_vec());
            tau0_loc = double(0);
            vals_r__ = context__.vals_r("tau0_loc");
            pos__ = 0;
            tau0_loc = vals_r__[pos__++];
            current_statement_begin__ = 180;
            context__.validate_dims("data initialization", "tau0_scale", "double", context__.to_vec());
            tau0_scale = double(0);
            vals_r__ = context__.vals_r("tau0_scale");
            pos__ = 0;
            tau0_scale = vals_r__[pos__++];
            current_statement_begin__ = 181;
            validate_non_negative_index("tau0_p", "2", 2);
            context__.validate_dims("data initialization", "tau0_p", "double", context__.to_vec(2));
            validate_non_negative_index("tau0_p", "2", 2);
            tau0_p = std::vector<double>(2,double(0));
            vals_r__ = context__.vals_r("tau0_p");
            pos__ = 0;
            size_t tau0_p_limit_0__ = 2;
            for (size_t i_0__ = 0; i_0__ < tau0_p_limit_0__; ++i_0__) {
                tau0_p[i_0__] = vals_r__[pos__++];
            }
            current_statement_begin__ = 182;
            context__.validate_dims("data initialization", "tau0_pdf", "int", context__.to_vec());
            tau0_pdf = int(0);
            vals_i__ = context__.vals_i("tau0_pdf");
            pos__ = 0;
            tau0_pdf = vals_i__[pos__++];
            current_statement_begin__ = 186;
            context__.validate_dims("data initialization", "K_lo", "double", context__.to_vec());
            K_lo = double(0);
            vals_r__ = context__.vals_r("K_lo");
            pos__ = 0;
            K_lo = vals_r__[pos__++];
            current_statement_begin__ = 187;
            context__.validate_dims("data initialization", "K_hi", "double", context__.to_vec());
            K_hi = double(0);
            vals_r__ = context__.vals_r("K_hi");
            pos__ = 0;
            K_hi = vals_r__[pos__++];
            current_statement_begin__ = 188;
            context__.validate_dims("data initialization", "K_loc", "double", context__.to_vec());
            K_loc = double(0);
            vals_r__ = context__.vals_r("K_loc");
            pos__ = 0;
            K_loc = vals_r__[pos__++];
            current_statement_begin__ = 189;
            context__.validate_dims("data initialization", "K_scale", "double", context__.to_vec());
            K_scale = double(0);
            vals_r__ = context__.vals_r("K_scale");
            pos__ = 0;
            K_scale = vals_r__[pos__++];
            current_statement_begin__ = 190;
            validate_non_negative_index("K_p", "2", 2);
            context__.validate_dims("data initialization", "K_p", "double", context__.to_vec(2));
            validate_non_negative_index("K_p", "2", 2);
            K_p = std::vector<double>(2,double(0));
            vals_r__ = context__.vals_r("K_p");
            pos__ = 0;
            size_t K_p_limit_0__ = 2;
            for (size_t i_0__ = 0; i_0__ < K_p_limit_0__; ++i_0__) {
                K_p[i_0__] = vals_r__[pos__++];
            }
            current_statement_begin__ = 191;
            context__.validate_dims("data initialization", "K_pdf", "int", context__.to_vec());
            K_pdf = int(0);
            vals_i__ = context__.vals_i("K_pdf");
            pos__ = 0;
            K_pdf = vals_i__[pos__++];
            current_statement_begin__ = 193;
            validate_non_negative_index("SC", "n_regions", n_regions);
            validate_non_negative_index("SC", "n_regions", n_regions);
            context__.validate_dims("data initialization", "SC", "matrix_d", context__.to_vec(n_regions,n_regions));
            validate_non_negative_index("SC", "n_regions", n_regions);
            validate_non_negative_index("SC", "n_regions", n_regions);
            SC = matrix_d(static_cast<Eigen::VectorXd::Index>(n_regions),static_cast<Eigen::VectorXd::Index>(n_regions));
            vals_r__ = context__.vals_r("SC");
            pos__ = 0;
            size_t SC_m_mat_lim__ = n_regions;
            size_t SC_n_mat_lim__ = n_regions;
            for (size_t n_mat__ = 0; n_mat__ < SC_n_mat_lim__; ++n_mat__) {
                for (size_t m_mat__ = 0; m_mat__ < SC_m_mat_lim__; ++m_mat__) {
                    SC(m_mat__,n_mat__) = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 195;
            context__.validate_dims("data initialization", "MC_split_lo", "double", context__.to_vec());
            MC_split_lo = double(0);
            vals_r__ = context__.vals_r("MC_split_lo");
            pos__ = 0;
            MC_split_lo = vals_r__[pos__++];
            current_statement_begin__ = 196;
            context__.validate_dims("data initialization", "MC_split_hi", "double", context__.to_vec());
            MC_split_hi = double(0);
            vals_r__ = context__.vals_r("MC_split_hi");
            pos__ = 0;
            MC_split_hi = vals_r__[pos__++];
            current_statement_begin__ = 197;
            validate_non_negative_index("MC_split_loc", "n_connections", n_connections);
            context__.validate_dims("data initialization", "MC_split_loc", "row_vector_d", context__.to_vec(n_connections));
            validate_non_negative_index("MC_split_loc", "n_connections", n_connections);
            MC_split_loc = row_vector_d(static_cast<Eigen::VectorXd::Index>(n_connections));
            vals_r__ = context__.vals_r("MC_split_loc");
            pos__ = 0;
            size_t MC_split_loc_i_vec_lim__ = n_connections;
            for (size_t i_vec__ = 0; i_vec__ < MC_split_loc_i_vec_lim__; ++i_vec__) {
                MC_split_loc[i_vec__] = vals_r__[pos__++];
            }
            current_statement_begin__ = 198;
            validate_non_negative_index("MC_split_scale", "n_connections", n_connections);
            context__.validate_dims("data initialization", "MC_split_scale", "row_vector_d", context__.to_vec(n_connections));
            validate_non_negative_index("MC_split_scale", "n_connections", n_connections);
            MC_split_scale = row_vector_d(static_cast<Eigen::VectorXd::Index>(n_connections));
            vals_r__ = context__.vals_r("MC_split_scale");
            pos__ = 0;
            size_t MC_split_scale_i_vec_lim__ = n_connections;
            for (size_t i_vec__ = 0; i_vec__ < MC_split_scale_i_vec_lim__; ++i_vec__) {
                MC_split_scale[i_vec__] = vals_r__[pos__++];
            }
            current_statement_begin__ = 200;
            context__.validate_dims("data initialization", "MC_scale", "double", context__.to_vec());
            MC_scale = double(0);
            vals_r__ = context__.vals_r("MC_scale");
            pos__ = 0;
            MC_scale = vals_r__[pos__++];
            current_statement_begin__ = 203;
            context__.validate_dims("data initialization", "dt", "double", context__.to_vec());
            dt = double(0);
            vals_r__ = context__.vals_r("dt");
            pos__ = 0;
            dt = vals_r__[pos__++];
            current_statement_begin__ = 205;
            context__.validate_dims("data initialization", "sig_eq", "double", context__.to_vec());
            sig_eq = double(0);
            vals_r__ = context__.vals_r("sig_eq");
            pos__ = 0;
            sig_eq = vals_r__[pos__++];
            current_statement_begin__ = 207;
            context__.validate_dims("data initialization", "sig_init", "double", context__.to_vec());
            sig_init = double(0);
            vals_r__ = context__.vals_r("sig_init");
            pos__ = 0;
            sig_init = vals_r__[pos__++];
            current_statement_begin__ = 209;
            context__.validate_dims("data initialization", "sig_lo", "double", context__.to_vec());
            sig_lo = double(0);
            vals_r__ = context__.vals_r("sig_lo");
            pos__ = 0;
            sig_lo = vals_r__[pos__++];
            current_statement_begin__ = 210;
            context__.validate_dims("data initialization", "sig_hi", "double", context__.to_vec());
            sig_hi = double(0);
            vals_r__ = context__.vals_r("sig_hi");
            pos__ = 0;
            sig_hi = vals_r__[pos__++];
            current_statement_begin__ = 211;
            context__.validate_dims("data initialization", "sig_loc", "double", context__.to_vec());
            sig_loc = double(0);
            vals_r__ = context__.vals_r("sig_loc");
            pos__ = 0;
            sig_loc = vals_r__[pos__++];
            current_statement_begin__ = 212;
            context__.validate_dims("data initialization", "sig_scale", "double", context__.to_vec());
            sig_scale = double(0);
            vals_r__ = context__.vals_r("sig_scale");
            pos__ = 0;
            sig_scale = vals_r__[pos__++];
            current_statement_begin__ = 213;
            validate_non_negative_index("sig_p", "2", 2);
            context__.validate_dims("data initialization", "sig_p", "double", context__.to_vec(2));
            validate_non_negative_index("sig_p", "2", 2);
            sig_p = std::vector<double>(2,double(0));
            vals_r__ = context__.vals_r("sig_p");
            pos__ = 0;
            size_t sig_p_limit_0__ = 2;
            for (size_t i_0__ = 0; i_0__ < sig_p_limit_0__; ++i_0__) {
                sig_p[i_0__] = vals_r__[pos__++];
            }
            current_statement_begin__ = 214;
            context__.validate_dims("data initialization", "sig_pdf", "int", context__.to_vec());
            sig_pdf = int(0);
            vals_i__ = context__.vals_i("sig_pdf");
            pos__ = 0;
            sig_pdf = vals_i__[pos__++];
            current_statement_begin__ = 217;
            context__.validate_dims("data initialization", "observation_model", "int", context__.to_vec());
            observation_model = int(0);
            vals_i__ = context__.vals_i("observation_model");
            pos__ = 0;
            observation_model = vals_i__[pos__++];
            current_statement_begin__ = 218;
            validate_non_negative_index("mixing", "n_signals", n_signals);
            validate_non_negative_index("mixing", "n_regions", n_regions);
            context__.validate_dims("data initialization", "mixing", "matrix_d", context__.to_vec(n_signals,n_regions));
            validate_non_negative_index("mixing", "n_signals", n_signals);
            validate_non_negative_index("mixing", "n_regions", n_regions);
            mixing = matrix_d(static_cast<Eigen::VectorXd::Index>(n_signals),static_cast<Eigen::VectorXd::Index>(n_regions));
            vals_r__ = context__.vals_r("mixing");
            pos__ = 0;
            size_t mixing_m_mat_lim__ = n_signals;
            size_t mixing_n_mat_lim__ = n_regions;
            for (size_t n_mat__ = 0; n_mat__ < mixing_n_mat_lim__; ++n_mat__) {
                for (size_t m_mat__ = 0; m_mat__ < mixing_m_mat_lim__; ++m_mat__) {
                    mixing(m_mat__,n_mat__) = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 219;
            validate_non_negative_index("signals", "n_times", n_times);
            validate_non_negative_index("signals", "n_signals", n_signals);
            context__.validate_dims("data initialization", "signals", "row_vector_d", context__.to_vec(n_times,n_signals));
            validate_non_negative_index("signals", "n_times", n_times);
            validate_non_negative_index("signals", "n_signals", n_signals);
            signals = std::vector<row_vector_d>(n_times,row_vector_d(static_cast<Eigen::VectorXd::Index>(n_signals)));
            vals_r__ = context__.vals_r("signals");
            pos__ = 0;
            size_t signals_i_vec_lim__ = n_signals;
            for (size_t i_vec__ = 0; i_vec__ < signals_i_vec_lim__; ++i_vec__) {
                size_t signals_limit_0__ = n_times;
                for (size_t i_0__ = 0; i_0__ < signals_limit_0__; ++i_0__) {
                    signals[i_0__][i_vec__] = vals_r__[pos__++];
            }
            }
            current_statement_begin__ = 221;
            context__.validate_dims("data initialization", "eps_lo", "double", context__.to_vec());
            eps_lo = double(0);
            vals_r__ = context__.vals_r("eps_lo");
            pos__ = 0;
            eps_lo = vals_r__[pos__++];
            current_statement_begin__ = 222;
            context__.validate_dims("data initialization", "eps_hi", "double", context__.to_vec());
            eps_hi = double(0);
            vals_r__ = context__.vals_r("eps_hi");
            pos__ = 0;
            eps_hi = vals_r__[pos__++];
            current_statement_begin__ = 223;
            context__.validate_dims("data initialization", "eps_loc", "double", context__.to_vec());
            eps_loc = double(0);
            vals_r__ = context__.vals_r("eps_loc");
            pos__ = 0;
            eps_loc = vals_r__[pos__++];
            current_statement_begin__ = 224;
            context__.validate_dims("data initialization", "eps_scale", "double", context__.to_vec());
            eps_scale = double(0);
            vals_r__ = context__.vals_r("eps_scale");
            pos__ = 0;
            eps_scale = vals_r__[pos__++];
            current_statement_begin__ = 225;
            validate_non_negative_index("eps_p", "2", 2);
            context__.validate_dims("data initialization", "eps_p", "double", context__.to_vec(2));
            validate_non_negative_index("eps_p", "2", 2);
            eps_p = std::vector<double>(2,double(0));
            vals_r__ = context__.vals_r("eps_p");
            pos__ = 0;
            size_t eps_p_limit_0__ = 2;
            for (size_t i_0__ = 0; i_0__ < eps_p_limit_0__; ++i_0__) {
                eps_p[i_0__] = vals_r__[pos__++];
            }
            current_statement_begin__ = 226;
            context__.validate_dims("data initialization", "eps_pdf", "int", context__.to_vec());
            eps_pdf = int(0);
            vals_i__ = context__.vals_i("eps_pdf");
            pos__ = 0;
            eps_pdf = vals_i__[pos__++];
            current_statement_begin__ = 228;
            context__.validate_dims("data initialization", "scale_signal_lo", "double", context__.to_vec());
            scale_signal_lo = double(0);
            vals_r__ = context__.vals_r("scale_signal_lo");
            pos__ = 0;
            scale_signal_lo = vals_r__[pos__++];
            current_statement_begin__ = 229;
            context__.validate_dims("data initialization", "scale_signal_hi", "double", context__.to_vec());
            scale_signal_hi = double(0);
            vals_r__ = context__.vals_r("scale_signal_hi");
            pos__ = 0;
            scale_signal_hi = vals_r__[pos__++];
            current_statement_begin__ = 230;
            context__.validate_dims("data initialization", "scale_signal_loc", "double", context__.to_vec());
            scale_signal_loc = double(0);
            vals_r__ = context__.vals_r("scale_signal_loc");
            pos__ = 0;
            scale_signal_loc = vals_r__[pos__++];
            current_statement_begin__ = 231;
            context__.validate_dims("data initialization", "scale_signal_scale", "double", context__.to_vec());
            scale_signal_scale = double(0);
            vals_r__ = context__.vals_r("scale_signal_scale");
            pos__ = 0;
            scale_signal_scale = vals_r__[pos__++];
            current_statement_begin__ = 232;
            validate_non_negative_index("scale_signal_p", "2", 2);
            context__.validate_dims("data initialization", "scale_signal_p", "double", context__.to_vec(2));
            validate_non_negative_index("scale_signal_p", "2", 2);
            scale_signal_p = std::vector<double>(2,double(0));
            vals_r__ = context__.vals_r("scale_signal_p");
            pos__ = 0;
            size_t scale_signal_p_limit_0__ = 2;
            for (size_t i_0__ = 0; i_0__ < scale_signal_p_limit_0__; ++i_0__) {
                scale_signal_p[i_0__] = vals_r__[pos__++];
            }
            current_statement_begin__ = 233;
            context__.validate_dims("data initialization", "scale_signal_pdf", "int", context__.to_vec());
            scale_signal_pdf = int(0);
            vals_i__ = context__.vals_i("scale_signal_pdf");
            pos__ = 0;
            scale_signal_pdf = vals_i__[pos__++];
            current_statement_begin__ = 235;
            context__.validate_dims("data initialization", "offset_signal_lo", "double", context__.to_vec());
            offset_signal_lo = double(0);
            vals_r__ = context__.vals_r("offset_signal_lo");
            pos__ = 0;
            offset_signal_lo = vals_r__[pos__++];
            current_statement_begin__ = 236;
            context__.validate_dims("data initialization", "offset_signal_hi", "double", context__.to_vec());
            offset_signal_hi = double(0);
            vals_r__ = context__.vals_r("offset_signal_hi");
            pos__ = 0;
            offset_signal_hi = vals_r__[pos__++];
            current_statement_begin__ = 237;
            context__.validate_dims("data initialization", "offset_signal_loc", "double", context__.to_vec());
            offset_signal_loc = double(0);
            vals_r__ = context__.vals_r("offset_signal_loc");
            pos__ = 0;
            offset_signal_loc = vals_r__[pos__++];
            current_statement_begin__ = 238;
            context__.validate_dims("data initialization", "offset_signal_scale", "double", context__.to_vec());
            offset_signal_scale = double(0);
            vals_r__ = context__.vals_r("offset_signal_scale");
            pos__ = 0;
            offset_signal_scale = vals_r__[pos__++];

            // validate, data variables
            current_statement_begin__ = 118;
            current_statement_begin__ = 119;
            current_statement_begin__ = 121;
            current_statement_begin__ = 122;
            current_statement_begin__ = 123;
            current_statement_begin__ = 124;
            current_statement_begin__ = 125;
            current_statement_begin__ = 126;
            current_statement_begin__ = 129;
            current_statement_begin__ = 130;
            current_statement_begin__ = 147;
            current_statement_begin__ = 148;
            current_statement_begin__ = 149;
            current_statement_begin__ = 150;
            current_statement_begin__ = 151;
            current_statement_begin__ = 152;
            current_statement_begin__ = 153;
            current_statement_begin__ = 154;
            current_statement_begin__ = 158;
            current_statement_begin__ = 159;
            current_statement_begin__ = 160;
            current_statement_begin__ = 164;
            current_statement_begin__ = 165;
            current_statement_begin__ = 167;
            current_statement_begin__ = 168;
            current_statement_begin__ = 170;
            check_greater_or_equal(function__,"tau1_lo",tau1_lo,0.0);
            current_statement_begin__ = 171;
            check_greater_or_equal(function__,"tau1_hi",tau1_hi,0.0);
            current_statement_begin__ = 172;
            current_statement_begin__ = 173;
            check_greater_or_equal(function__,"tau1_scale",tau1_scale,0.0);
            current_statement_begin__ = 174;
            current_statement_begin__ = 175;
            check_greater_or_equal(function__,"tau1_pdf",tau1_pdf,0);
            current_statement_begin__ = 177;
            check_greater_or_equal(function__,"tau0_lo",tau0_lo,0.0);
            current_statement_begin__ = 178;
            check_greater_or_equal(function__,"tau0_hi",tau0_hi,0.0);
            current_statement_begin__ = 179;
            current_statement_begin__ = 180;
            check_greater_or_equal(function__,"tau0_scale",tau0_scale,0.0);
            current_statement_begin__ = 181;
            current_statement_begin__ = 182;
            check_greater_or_equal(function__,"tau0_pdf",tau0_pdf,0);
            current_statement_begin__ = 186;
            check_greater_or_equal(function__,"K_lo",K_lo,0.0);
            current_statement_begin__ = 187;
            check_greater_or_equal(function__,"K_hi",K_hi,0.0);
            current_statement_begin__ = 188;
            current_statement_begin__ = 189;
            check_greater_or_equal(function__,"K_scale",K_scale,0.0);
            current_statement_begin__ = 190;
            current_statement_begin__ = 191;
            check_greater_or_equal(function__,"K_pdf",K_pdf,0);
            current_statement_begin__ = 193;
            check_greater_or_equal(function__,"SC",SC,0.0);
            current_statement_begin__ = 195;
            check_greater_or_equal(function__,"MC_split_lo",MC_split_lo,0.0);
            current_statement_begin__ = 196;
            check_greater_or_equal(function__,"MC_split_hi",MC_split_hi,0.0);
            current_statement_begin__ = 197;
            check_greater_or_equal(function__,"MC_split_loc",MC_split_loc,0.0);
            check_less_or_equal(function__,"MC_split_loc",MC_split_loc,1.0);
            current_statement_begin__ = 198;
            check_greater_or_equal(function__,"MC_split_scale",MC_split_scale,0.0);
            current_statement_begin__ = 200;
            check_greater_or_equal(function__,"MC_scale",MC_scale,0.0);
            current_statement_begin__ = 203;
            current_statement_begin__ = 205;
            check_greater_or_equal(function__,"sig_eq",sig_eq,0.0);
            current_statement_begin__ = 207;
            check_greater_or_equal(function__,"sig_init",sig_init,0.0);
            current_statement_begin__ = 209;
            check_greater_or_equal(function__,"sig_lo",sig_lo,0.0);
            current_statement_begin__ = 210;
            check_greater_or_equal(function__,"sig_hi",sig_hi,0.0);
            current_statement_begin__ = 211;
            current_statement_begin__ = 212;
            check_greater_or_equal(function__,"sig_scale",sig_scale,0.0);
            current_statement_begin__ = 213;
            current_statement_begin__ = 214;
            check_greater_or_equal(function__,"sig_pdf",sig_pdf,0);
            current_statement_begin__ = 217;
            current_statement_begin__ = 218;
            current_statement_begin__ = 219;
            current_statement_begin__ = 221;
            check_greater_or_equal(function__,"eps_lo",eps_lo,0.0);
            current_statement_begin__ = 222;
            check_greater_or_equal(function__,"eps_hi",eps_hi,0.0);
            current_statement_begin__ = 223;
            current_statement_begin__ = 224;
            check_greater_or_equal(function__,"eps_scale",eps_scale,0.0);
            current_statement_begin__ = 225;
            current_statement_begin__ = 226;
            check_greater_or_equal(function__,"eps_pdf",eps_pdf,0);
            current_statement_begin__ = 228;
            check_greater_or_equal(function__,"scale_signal_lo",scale_signal_lo,0.0);
            current_statement_begin__ = 229;
            check_greater_or_equal(function__,"scale_signal_hi",scale_signal_hi,0.0);
            current_statement_begin__ = 230;
            current_statement_begin__ = 231;
            check_greater_or_equal(function__,"scale_signal_scale",scale_signal_scale,0.0);
            current_statement_begin__ = 232;
            current_statement_begin__ = 233;
            check_greater_or_equal(function__,"scale_signal_pdf",scale_signal_pdf,0);
            current_statement_begin__ = 235;
            current_statement_begin__ = 236;
            current_statement_begin__ = 237;
            current_statement_begin__ = 238;
            check_greater_or_equal(function__,"offset_signal_scale",offset_signal_scale,0.0);
            // initialize data variables
            current_statement_begin__ = 246;
            db = double(0);
            stan::math::fill(db,DUMMY_VAR__);
            stan::math::assign(db,(d - b));
            current_statement_begin__ = 247;
            sqrtdt = double(0);
            stan::math::fill(sqrtdt,DUMMY_VAR__);
            stan::math::assign(sqrtdt,sqrt(dt));
            current_statement_begin__ = 248;
            validate_non_negative_index("zeros", "n_regions", n_regions);
            zeros = row_vector_d(static_cast<Eigen::VectorXd::Index>(n_regions));
            stan::math::fill(zeros,DUMMY_VAR__);
            stan::math::assign(zeros,rep_row_vector(0.0,n_regions));
            current_statement_begin__ = 251;
            tau1_star_lo = double(0);
            stan::math::fill(tau1_star_lo,DUMMY_VAR__);
            stan::math::assign(tau1_star_lo,((tau1_lo - tau1_loc) / tau1_scale));
            current_statement_begin__ = 252;
            tau1_star_hi = double(0);
            stan::math::fill(tau1_star_hi,DUMMY_VAR__);
            stan::math::assign(tau1_star_hi,((tau1_hi - tau1_loc) / tau1_scale));
            current_statement_begin__ = 253;
            tau0_star_lo = double(0);
            stan::math::fill(tau0_star_lo,DUMMY_VAR__);
            stan::math::assign(tau0_star_lo,((tau0_lo - tau0_loc) / tau0_scale));
            current_statement_begin__ = 254;
            tau0_star_hi = double(0);
            stan::math::fill(tau0_star_hi,DUMMY_VAR__);
            stan::math::assign(tau0_star_hi,((tau0_hi - tau0_loc) / tau0_scale));
            current_statement_begin__ = 255;
            K_star_lo = double(0);
            stan::math::fill(K_star_lo,DUMMY_VAR__);
            stan::math::assign(K_star_lo,((K_lo - K_loc) / K_scale));
            current_statement_begin__ = 256;
            K_star_hi = double(0);
            stan::math::fill(K_star_hi,DUMMY_VAR__);
            stan::math::assign(K_star_hi,((K_hi - K_loc) / K_scale));
            current_statement_begin__ = 257;
            sig_star_lo = double(0);
            stan::math::fill(sig_star_lo,DUMMY_VAR__);
            stan::math::assign(sig_star_lo,((sig_lo - sig_loc) / sig_scale));
            current_statement_begin__ = 258;
            sig_star_hi = double(0);
            stan::math::fill(sig_star_hi,DUMMY_VAR__);
            stan::math::assign(sig_star_hi,((sig_hi - sig_loc) / sig_scale));
            current_statement_begin__ = 259;
            eps_star_lo = double(0);
            stan::math::fill(eps_star_lo,DUMMY_VAR__);
            stan::math::assign(eps_star_lo,((eps_lo - eps_loc) / eps_scale));
            current_statement_begin__ = 260;
            eps_star_hi = double(0);
            stan::math::fill(eps_star_hi,DUMMY_VAR__);
            stan::math::assign(eps_star_hi,((eps_hi - eps_loc) / eps_scale));
            current_statement_begin__ = 261;
            scale_signal_star_lo = double(0);
            stan::math::fill(scale_signal_star_lo,DUMMY_VAR__);
            stan::math::assign(scale_signal_star_lo,((scale_signal_lo - scale_signal_loc) / scale_signal_scale));
            current_statement_begin__ = 262;
            scale_signal_star_hi = double(0);
            stan::math::fill(scale_signal_star_hi,DUMMY_VAR__);
            stan::math::assign(scale_signal_star_hi,((scale_signal_hi - scale_signal_loc) / scale_signal_scale));


            // validate transformed data
            current_statement_begin__ = 246;
            current_statement_begin__ = 247;
            current_statement_begin__ = 248;
            current_statement_begin__ = 251;
            current_statement_begin__ = 252;
            current_statement_begin__ = 253;
            current_statement_begin__ = 254;
            current_statement_begin__ = 255;
            current_statement_begin__ = 256;
            current_statement_begin__ = 257;
            current_statement_begin__ = 258;
            current_statement_begin__ = 259;
            current_statement_begin__ = 260;
            current_statement_begin__ = 261;
            current_statement_begin__ = 262;

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            current_statement_begin__ = 270;
        validate_non_negative_index("x1eq", "n_regions", n_regions);
            num_params_r__ += n_regions;
            current_statement_begin__ = 271;
        validate_non_negative_index("x1init", "n_regions", n_regions);
            num_params_r__ += n_regions;
            current_statement_begin__ = 272;
        validate_non_negative_index("zinit", "n_regions", n_regions);
            num_params_r__ += n_regions;
            current_statement_begin__ = 274;
        validate_non_negative_index("z_dWt", "n_active_regions", n_active_regions);
            validate_non_negative_index("z_dWt", "n_times", n_times);
            num_params_r__ += n_active_regions * n_times;
            current_statement_begin__ = 275;
            ++num_params_r__;
            current_statement_begin__ = 276;
            ++num_params_r__;
            current_statement_begin__ = 278;
            ++num_params_r__;
            current_statement_begin__ = 279;
        validate_non_negative_index("MC_split", "n_connections", n_connections);
            num_params_r__ += n_connections;
            current_statement_begin__ = 280;
        validate_non_negative_index("MC", "n_regions", n_regions);
            validate_non_negative_index("MC", "n_regions", n_regions);
            num_params_r__ += n_regions * n_regions;
            current_statement_begin__ = 283;
            ++num_params_r__;
            current_statement_begin__ = 286;
            ++num_params_r__;
            current_statement_begin__ = 287;
            ++num_params_r__;
            current_statement_begin__ = 288;
            ++num_params_r__;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~vep_sde_model() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("x1eq")))
            throw std::runtime_error("variable x1eq missing");
        vals_r__ = context__.vals_r("x1eq");
        pos__ = 0U;
        validate_non_negative_index("x1eq", "n_regions", n_regions);
        context__.validate_dims("initialization", "x1eq", "row_vector_d", context__.to_vec(n_regions));
        row_vector_d x1eq(static_cast<Eigen::VectorXd::Index>(n_regions));
        for (int j1__ = 0U; j1__ < n_regions; ++j1__)
            x1eq(j1__) = vals_r__[pos__++];
        try {
            writer__.row_vector_lub_unconstrain(x1eq_lo,x1eq_hi,x1eq);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable x1eq: ") + e.what());
        }

        if (!(context__.contains_r("x1init")))
            throw std::runtime_error("variable x1init missing");
        vals_r__ = context__.vals_r("x1init");
        pos__ = 0U;
        validate_non_negative_index("x1init", "n_regions", n_regions);
        context__.validate_dims("initialization", "x1init", "row_vector_d", context__.to_vec(n_regions));
        row_vector_d x1init(static_cast<Eigen::VectorXd::Index>(n_regions));
        for (int j1__ = 0U; j1__ < n_regions; ++j1__)
            x1init(j1__) = vals_r__[pos__++];
        try {
            writer__.row_vector_lub_unconstrain(x1init_lo,x1init_hi,x1init);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable x1init: ") + e.what());
        }

        if (!(context__.contains_r("zinit")))
            throw std::runtime_error("variable zinit missing");
        vals_r__ = context__.vals_r("zinit");
        pos__ = 0U;
        validate_non_negative_index("zinit", "n_regions", n_regions);
        context__.validate_dims("initialization", "zinit", "row_vector_d", context__.to_vec(n_regions));
        row_vector_d zinit(static_cast<Eigen::VectorXd::Index>(n_regions));
        for (int j1__ = 0U; j1__ < n_regions; ++j1__)
            zinit(j1__) = vals_r__[pos__++];
        try {
            writer__.row_vector_lub_unconstrain(zinit_lo,zinit_hi,zinit);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable zinit: ") + e.what());
        }

        if (!(context__.contains_r("z_dWt")))
            throw std::runtime_error("variable z_dWt missing");
        vals_r__ = context__.vals_r("z_dWt");
        pos__ = 0U;
        validate_non_negative_index("z_dWt", "n_times", n_times);
        validate_non_negative_index("z_dWt", "n_active_regions", n_active_regions);
        context__.validate_dims("initialization", "z_dWt", "row_vector_d", context__.to_vec(n_times,n_active_regions));
        std::vector<row_vector_d> z_dWt(n_times,row_vector_d(static_cast<Eigen::VectorXd::Index>(n_active_regions)));
        for (int j1__ = 0U; j1__ < n_active_regions; ++j1__)
            for (int i0__ = 0U; i0__ < n_times; ++i0__)
                z_dWt[i0__](j1__) = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < n_times; ++i0__)
            try {
            writer__.row_vector_unconstrain(z_dWt[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable z_dWt: ") + e.what());
        }

        if (!(context__.contains_r("tau1_star")))
            throw std::runtime_error("variable tau1_star missing");
        vals_r__ = context__.vals_r("tau1_star");
        pos__ = 0U;
        context__.validate_dims("initialization", "tau1_star", "double", context__.to_vec());
        double tau1_star(0);
        tau1_star = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(tau1_star_lo,tau1_star_hi,tau1_star);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable tau1_star: ") + e.what());
        }

        if (!(context__.contains_r("tau0_star")))
            throw std::runtime_error("variable tau0_star missing");
        vals_r__ = context__.vals_r("tau0_star");
        pos__ = 0U;
        context__.validate_dims("initialization", "tau0_star", "double", context__.to_vec());
        double tau0_star(0);
        tau0_star = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(tau0_star_lo,tau0_star_hi,tau0_star);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable tau0_star: ") + e.what());
        }

        if (!(context__.contains_r("K_star")))
            throw std::runtime_error("variable K_star missing");
        vals_r__ = context__.vals_r("K_star");
        pos__ = 0U;
        context__.validate_dims("initialization", "K_star", "double", context__.to_vec());
        double K_star(0);
        K_star = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(K_star_lo,K_star_hi,K_star);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable K_star: ") + e.what());
        }

        if (!(context__.contains_r("MC_split")))
            throw std::runtime_error("variable MC_split missing");
        vals_r__ = context__.vals_r("MC_split");
        pos__ = 0U;
        validate_non_negative_index("MC_split", "n_connections", n_connections);
        context__.validate_dims("initialization", "MC_split", "row_vector_d", context__.to_vec(n_connections));
        row_vector_d MC_split(static_cast<Eigen::VectorXd::Index>(n_connections));
        for (int j1__ = 0U; j1__ < n_connections; ++j1__)
            MC_split(j1__) = vals_r__[pos__++];
        try {
            writer__.row_vector_unconstrain(MC_split);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable MC_split: ") + e.what());
        }

        if (!(context__.contains_r("MC")))
            throw std::runtime_error("variable MC missing");
        vals_r__ = context__.vals_r("MC");
        pos__ = 0U;
        validate_non_negative_index("MC", "n_regions", n_regions);
        validate_non_negative_index("MC", "n_regions", n_regions);
        context__.validate_dims("initialization", "MC", "matrix_d", context__.to_vec(n_regions,n_regions));
        matrix_d MC(static_cast<Eigen::VectorXd::Index>(n_regions),static_cast<Eigen::VectorXd::Index>(n_regions));
        for (int j2__ = 0U; j2__ < n_regions; ++j2__)
            for (int j1__ = 0U; j1__ < n_regions; ++j1__)
                MC(j1__,j2__) = vals_r__[pos__++];
        try {
            writer__.matrix_lb_unconstrain(0.0,MC);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable MC: ") + e.what());
        }

        if (!(context__.contains_r("sig_star")))
            throw std::runtime_error("variable sig_star missing");
        vals_r__ = context__.vals_r("sig_star");
        pos__ = 0U;
        context__.validate_dims("initialization", "sig_star", "double", context__.to_vec());
        double sig_star(0);
        sig_star = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(sig_star_lo,sig_star_hi,sig_star);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable sig_star: ") + e.what());
        }

        if (!(context__.contains_r("eps_star")))
            throw std::runtime_error("variable eps_star missing");
        vals_r__ = context__.vals_r("eps_star");
        pos__ = 0U;
        context__.validate_dims("initialization", "eps_star", "double", context__.to_vec());
        double eps_star(0);
        eps_star = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(eps_star_lo,eps_star_hi,eps_star);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable eps_star: ") + e.what());
        }

        if (!(context__.contains_r("scale_signal_star")))
            throw std::runtime_error("variable scale_signal_star missing");
        vals_r__ = context__.vals_r("scale_signal_star");
        pos__ = 0U;
        context__.validate_dims("initialization", "scale_signal_star", "double", context__.to_vec());
        double scale_signal_star(0);
        scale_signal_star = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(scale_signal_star_lo,scale_signal_star_hi,scale_signal_star);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable scale_signal_star: ") + e.what());
        }

        if (!(context__.contains_r("offset_signal")))
            throw std::runtime_error("variable offset_signal missing");
        vals_r__ = context__.vals_r("offset_signal");
        pos__ = 0U;
        context__.validate_dims("initialization", "offset_signal", "double", context__.to_vec());
        double offset_signal(0);
        offset_signal = vals_r__[pos__++];
        try {
            writer__.scalar_lub_unconstrain(offset_signal_lo,offset_signal_hi,offset_signal);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable offset_signal: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,1,Eigen::Dynamic>  x1eq;
            (void) x1eq;  // dummy to suppress unused var warning
            if (jacobian__)
                x1eq = in__.row_vector_lub_constrain(x1eq_lo,x1eq_hi,n_regions,lp__);
            else
                x1eq = in__.row_vector_lub_constrain(x1eq_lo,x1eq_hi,n_regions);

            Eigen::Matrix<T__,1,Eigen::Dynamic>  x1init;
            (void) x1init;  // dummy to suppress unused var warning
            if (jacobian__)
                x1init = in__.row_vector_lub_constrain(x1init_lo,x1init_hi,n_regions,lp__);
            else
                x1init = in__.row_vector_lub_constrain(x1init_lo,x1init_hi,n_regions);

            Eigen::Matrix<T__,1,Eigen::Dynamic>  zinit;
            (void) zinit;  // dummy to suppress unused var warning
            if (jacobian__)
                zinit = in__.row_vector_lub_constrain(zinit_lo,zinit_hi,n_regions,lp__);
            else
                zinit = in__.row_vector_lub_constrain(zinit_lo,zinit_hi,n_regions);

            vector<Eigen::Matrix<T__,1,Eigen::Dynamic> > z_dWt;
            size_t dim_z_dWt_0__ = n_times;
            z_dWt.reserve(dim_z_dWt_0__);
            for (size_t k_0__ = 0; k_0__ < dim_z_dWt_0__; ++k_0__) {
                if (jacobian__)
                    z_dWt.push_back(in__.row_vector_constrain(n_active_regions,lp__));
                else
                    z_dWt.push_back(in__.row_vector_constrain(n_active_regions));
            }

            T__ tau1_star;
            (void) tau1_star;  // dummy to suppress unused var warning
            if (jacobian__)
                tau1_star = in__.scalar_lub_constrain(tau1_star_lo,tau1_star_hi,lp__);
            else
                tau1_star = in__.scalar_lub_constrain(tau1_star_lo,tau1_star_hi);

            T__ tau0_star;
            (void) tau0_star;  // dummy to suppress unused var warning
            if (jacobian__)
                tau0_star = in__.scalar_lub_constrain(tau0_star_lo,tau0_star_hi,lp__);
            else
                tau0_star = in__.scalar_lub_constrain(tau0_star_lo,tau0_star_hi);

            T__ K_star;
            (void) K_star;  // dummy to suppress unused var warning
            if (jacobian__)
                K_star = in__.scalar_lub_constrain(K_star_lo,K_star_hi,lp__);
            else
                K_star = in__.scalar_lub_constrain(K_star_lo,K_star_hi);

            Eigen::Matrix<T__,1,Eigen::Dynamic>  MC_split;
            (void) MC_split;  // dummy to suppress unused var warning
            if (jacobian__)
                MC_split = in__.row_vector_constrain(n_connections,lp__);
            else
                MC_split = in__.row_vector_constrain(n_connections);

            Eigen::Matrix<T__,Eigen::Dynamic,Eigen::Dynamic>  MC;
            (void) MC;  // dummy to suppress unused var warning
            if (jacobian__)
                MC = in__.matrix_lb_constrain(0.0,n_regions,n_regions,lp__);
            else
                MC = in__.matrix_lb_constrain(0.0,n_regions,n_regions);

            T__ sig_star;
            (void) sig_star;  // dummy to suppress unused var warning
            if (jacobian__)
                sig_star = in__.scalar_lub_constrain(sig_star_lo,sig_star_hi,lp__);
            else
                sig_star = in__.scalar_lub_constrain(sig_star_lo,sig_star_hi);

            T__ eps_star;
            (void) eps_star;  // dummy to suppress unused var warning
            if (jacobian__)
                eps_star = in__.scalar_lub_constrain(eps_star_lo,eps_star_hi,lp__);
            else
                eps_star = in__.scalar_lub_constrain(eps_star_lo,eps_star_hi);

            T__ scale_signal_star;
            (void) scale_signal_star;  // dummy to suppress unused var warning
            if (jacobian__)
                scale_signal_star = in__.scalar_lub_constrain(scale_signal_star_lo,scale_signal_star_hi,lp__);
            else
                scale_signal_star = in__.scalar_lub_constrain(scale_signal_star_lo,scale_signal_star_hi);

            T__ offset_signal;
            (void) offset_signal;  // dummy to suppress unused var warning
            if (jacobian__)
                offset_signal = in__.scalar_lub_constrain(offset_signal_lo,offset_signal_hi,lp__);
            else
                offset_signal = in__.scalar_lub_constrain(offset_signal_lo,offset_signal_hi);


            // transformed parameters
            current_statement_begin__ = 297;
            validate_non_negative_index("x1", "n_regions", n_regions);
            validate_non_negative_index("x1", "n_times", n_times);
            vector<Eigen::Matrix<T__,1,Eigen::Dynamic> > x1(n_times, (Eigen::Matrix<T__,1,Eigen::Dynamic> (static_cast<Eigen::VectorXd::Index>(n_regions))));
            stan::math::initialize(x1, DUMMY_VAR__);
            stan::math::fill(x1,DUMMY_VAR__);
            current_statement_begin__ = 298;
            validate_non_negative_index("z", "n_regions", n_regions);
            validate_non_negative_index("z", "n_times", n_times);
            vector<Eigen::Matrix<T__,1,Eigen::Dynamic> > z(n_times, (Eigen::Matrix<T__,1,Eigen::Dynamic> (static_cast<Eigen::VectorXd::Index>(n_regions))));
            stan::math::initialize(z, DUMMY_VAR__);
            stan::math::fill(z,DUMMY_VAR__);
            current_statement_begin__ = 299;
            T__ tau1;
            (void) tau1;  // dummy to suppress unused var warning

            stan::math::initialize(tau1, DUMMY_VAR__);
            stan::math::fill(tau1,DUMMY_VAR__);
            stan::math::assign(tau1,((tau1_star * tau1_scale) + tau1_loc));
            current_statement_begin__ = 300;
            T__ tau0;
            (void) tau0;  // dummy to suppress unused var warning

            stan::math::initialize(tau0, DUMMY_VAR__);
            stan::math::fill(tau0,DUMMY_VAR__);
            stan::math::assign(tau0,((tau0_star * tau0_scale) + tau0_loc));
            current_statement_begin__ = 302;
            validate_non_negative_index("zeq", "n_regions", n_regions);
            Eigen::Matrix<T__,1,Eigen::Dynamic>  zeq(static_cast<Eigen::VectorXd::Index>(n_regions));
            (void) zeq;  // dummy to suppress unused var warning

            stan::math::initialize(zeq, DUMMY_VAR__);
            stan::math::fill(zeq,DUMMY_VAR__);
            stan::math::assign(zeq,EpileptorDP2D_fun_x1(n_regions,x1eq,zeros,yc,Iext1,a,db,d,slope,1.0, pstream__));
            current_statement_begin__ = 305;
            T__ K;
            (void) K;  // dummy to suppress unused var warning

            stan::math::initialize(K, DUMMY_VAR__);
            stan::math::fill(K,DUMMY_VAR__);
            stan::math::assign(K,((K_star * K_scale) + K_loc));
            current_statement_begin__ = 306;
            validate_non_negative_index("coupling_eq", "n_regions", n_regions);
            Eigen::Matrix<T__,1,Eigen::Dynamic>  coupling_eq(static_cast<Eigen::VectorXd::Index>(n_regions));
            (void) coupling_eq;  // dummy to suppress unused var warning

            stan::math::initialize(coupling_eq, DUMMY_VAR__);
            stan::math::fill(coupling_eq,DUMMY_VAR__);
            stan::math::assign(coupling_eq,calc_coupling(n_regions,n_regions,x1eq,x1eq,MC, pstream__));
            current_statement_begin__ = 307;
            validate_non_negative_index("coupling", "n_regions", n_regions);
            validate_non_negative_index("coupling", "n_times", n_times);
            vector<Eigen::Matrix<T__,1,Eigen::Dynamic> > coupling(n_times, (Eigen::Matrix<T__,1,Eigen::Dynamic> (static_cast<Eigen::VectorXd::Index>(n_regions))));
            stan::math::initialize(coupling, DUMMY_VAR__);
            stan::math::fill(coupling,DUMMY_VAR__);
            current_statement_begin__ = 310;
            validate_non_negative_index("x0", "n_regions", n_regions);
            Eigen::Matrix<T__,1,Eigen::Dynamic>  x0(static_cast<Eigen::VectorXd::Index>(n_regions));
            (void) x0;  // dummy to suppress unused var warning

            stan::math::initialize(x0, DUMMY_VAR__);
            stan::math::fill(x0,DUMMY_VAR__);
            stan::math::assign(x0,divide(EpileptorDP2D_fun_z_lin(n_regions,x1eq,zeq,zeros,multiply(K,coupling_eq),1.0,1.0, pstream__),4.0));
            current_statement_begin__ = 313;
            validate_non_negative_index("fit_signals", "n_signals", n_signals);
            validate_non_negative_index("fit_signals", "n_times", n_times);
            vector<Eigen::Matrix<T__,1,Eigen::Dynamic> > fit_signals(n_times, (Eigen::Matrix<T__,1,Eigen::Dynamic> (static_cast<Eigen::VectorXd::Index>(n_signals))));
            stan::math::initialize(fit_signals, DUMMY_VAR__);
            stan::math::fill(fit_signals,DUMMY_VAR__);
            current_statement_begin__ = 314;
            T__ eps;
            (void) eps;  // dummy to suppress unused var warning

            stan::math::initialize(eps, DUMMY_VAR__);
            stan::math::fill(eps,DUMMY_VAR__);
            stan::math::assign(eps,((eps_star * eps_scale) + eps_loc));
            current_statement_begin__ = 315;
            T__ scale_signal;
            (void) scale_signal;  // dummy to suppress unused var warning

            stan::math::initialize(scale_signal, DUMMY_VAR__);
            stan::math::fill(scale_signal,DUMMY_VAR__);
            stan::math::assign(scale_signal,((scale_signal_star * scale_signal_scale) + scale_signal_loc));
            current_statement_begin__ = 318;
            T__ sig;
            (void) sig;  // dummy to suppress unused var warning

            stan::math::initialize(sig, DUMMY_VAR__);
            stan::math::fill(sig,DUMMY_VAR__);
            stan::math::assign(sig,((sig_star * sig_scale) + sig_loc));


            current_statement_begin__ = 320;
            stan::math::assign(get_base1_lhs(x1,1,"x1",1), x1init);
            current_statement_begin__ = 321;
            stan::math::assign(get_base1_lhs(z,1,"z",1), zinit);
            current_statement_begin__ = 322;
            stan::math::assign(get_base1_lhs(coupling,1,"coupling",1), calc_coupling(n_regions,n_regions,get_base1(x1,1,"x1",1),get_base1(x1,1,"x1",1),MC, pstream__));
            {
            current_statement_begin__ = 324;
            validate_non_negative_index("df", "n_regions", n_regions);
            Eigen::Matrix<T__,1,Eigen::Dynamic>  df(static_cast<Eigen::VectorXd::Index>(n_regions));
            (void) df;  // dummy to suppress unused var warning

            stan::math::initialize(df, DUMMY_VAR__);
            stan::math::fill(df,DUMMY_VAR__);
            current_statement_begin__ = 325;
            validate_non_negative_index("observation", "n_regions", n_regions);
            Eigen::Matrix<T__,1,Eigen::Dynamic>  observation(static_cast<Eigen::VectorXd::Index>(n_regions));
            (void) observation;  // dummy to suppress unused var warning

            stan::math::initialize(observation, DUMMY_VAR__);
            stan::math::fill(observation,DUMMY_VAR__);


            current_statement_begin__ = 327;
            for (int tt = 2; tt <= n_times; ++tt) {

                current_statement_begin__ = 328;
                stan::math::assign(df, EpileptorDP2D_fun_x1(n_regions,get_base1(x1,(tt - 1),"x1",1),get_base1(z,(tt - 1),"z",1),yc,Iext1,a,db,d,slope,tau1, pstream__));
                current_statement_begin__ = 329;
                stan::math::assign(get_base1_lhs(x1,tt,"x1",1), ode_step(n_regions,get_base1(x1,(tt - 1),"x1",1),df,dt, pstream__));
                current_statement_begin__ = 330;
                stan::math::assign(get_base1_lhs(coupling,tt,"coupling",1), calc_coupling(n_regions,n_regions,get_base1(x1,tt,"x1",1),get_base1(x1,tt,"x1",1),MC, pstream__));
                current_statement_begin__ = 331;
                stan::math::assign(df, EpileptorDP2D_fun_z_lin(n_regions,get_base1(x1,(tt - 1),"x1",1),get_base1(z,(tt - 1),"z",1),x0,multiply(K,get_base1(coupling,(tt - 1),"coupling",1)),tau0,tau1, pstream__));
                current_statement_begin__ = 332;
                stan::model::assign(z, 
                            stan::model::cons_list(stan::model::index_uni(tt), stan::model::cons_list(stan::model::index_multi(active_regions), stan::model::nil_index_list())), 
                            stan::model::deep_copy(sde_step(n_regions,stan::model::rvalue(z, stan::model::cons_list(stan::model::index_uni((tt - 1)), stan::model::cons_list(stan::model::index_multi(active_regions), stan::model::nil_index_list())), "z"),df,dt,multiply(get_base1(z_dWt,(tt - 1),"z_dWt",1),sqrtdt), pstream__)), 
                            "assigning variable z");
                current_statement_begin__ = 333;
                stan::model::assign(z, 
                            stan::model::cons_list(stan::model::index_uni(tt), stan::model::cons_list(stan::model::index_multi(nonactive_regions), stan::model::nil_index_list())), 
                            stan::model::deep_copy(ode_step(n_regions,stan::model::rvalue(z, stan::model::cons_list(stan::model::index_uni((tt - 1)), stan::model::cons_list(stan::model::index_multi(active_regions), stan::model::nil_index_list())), "z"),df,dt, pstream__)), 
                            "assigning variable z");
                current_statement_begin__ = 335;
                if (as_bool(logical_eq(observation_model,0))) {

                    current_statement_begin__ = 337;
                    stan::math::assign(get_base1_lhs(fit_signals,tt,"fit_signals",1), transpose(add(multiply(scale_signal,log(multiply(mixing,exp(transpose(get_base1(x1,tt,"x1",1)))))),offset_signal)));
                } else if (as_bool(logical_eq(observation_model,1))) {

                    current_statement_begin__ = 340;
                    stan::math::assign(get_base1_lhs(fit_signals,tt,"fit_signals",1), transpose(add(multiply(multiply(scale_signal,mixing),transpose(get_base1(x1,tt,"x1",1))),offset_signal)));
                } else {

                    current_statement_begin__ = 343;
                    stan::math::assign(get_base1_lhs(fit_signals,tt,"fit_signals",1), add(multiply(scale_signal,get_base1(x1,tt,"x1",1)),offset_signal));
                }
            }
            }

            // validate transformed parameters
            for (int i0__ = 0; i0__ < n_times; ++i0__) {
                for (int i1__ = 0; i1__ < n_regions; ++i1__) {
                    if (stan::math::is_uninitialized(x1[i0__](i1__))) {
                        std::stringstream msg__;
                        msg__ << "Undefined transformed parameter: x1" << '[' << i0__ << ']' << '[' << i1__ << ']';
                        throw std::runtime_error(msg__.str());
                    }
                }
            }
            for (int i0__ = 0; i0__ < n_times; ++i0__) {
                for (int i1__ = 0; i1__ < n_regions; ++i1__) {
                    if (stan::math::is_uninitialized(z[i0__](i1__))) {
                        std::stringstream msg__;
                        msg__ << "Undefined transformed parameter: z" << '[' << i0__ << ']' << '[' << i1__ << ']';
                        throw std::runtime_error(msg__.str());
                    }
                }
            }
            if (stan::math::is_uninitialized(tau1)) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: tau1";
                throw std::runtime_error(msg__.str());
            }
            if (stan::math::is_uninitialized(tau0)) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: tau0";
                throw std::runtime_error(msg__.str());
            }
            for (int i0__ = 0; i0__ < n_regions; ++i0__) {
                if (stan::math::is_uninitialized(zeq(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: zeq" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            if (stan::math::is_uninitialized(K)) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: K";
                throw std::runtime_error(msg__.str());
            }
            for (int i0__ = 0; i0__ < n_regions; ++i0__) {
                if (stan::math::is_uninitialized(coupling_eq(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: coupling_eq" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < n_times; ++i0__) {
                for (int i1__ = 0; i1__ < n_regions; ++i1__) {
                    if (stan::math::is_uninitialized(coupling[i0__](i1__))) {
                        std::stringstream msg__;
                        msg__ << "Undefined transformed parameter: coupling" << '[' << i0__ << ']' << '[' << i1__ << ']';
                        throw std::runtime_error(msg__.str());
                    }
                }
            }
            for (int i0__ = 0; i0__ < n_regions; ++i0__) {
                if (stan::math::is_uninitialized(x0(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: x0" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < n_times; ++i0__) {
                for (int i1__ = 0; i1__ < n_signals; ++i1__) {
                    if (stan::math::is_uninitialized(fit_signals[i0__](i1__))) {
                        std::stringstream msg__;
                        msg__ << "Undefined transformed parameter: fit_signals" << '[' << i0__ << ']' << '[' << i1__ << ']';
                        throw std::runtime_error(msg__.str());
                    }
                }
            }
            if (stan::math::is_uninitialized(eps)) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: eps";
                throw std::runtime_error(msg__.str());
            }
            if (stan::math::is_uninitialized(scale_signal)) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: scale_signal";
                throw std::runtime_error(msg__.str());
            }
            if (stan::math::is_uninitialized(sig)) {
                std::stringstream msg__;
                msg__ << "Undefined transformed parameter: sig";
                throw std::runtime_error(msg__.str());
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            current_statement_begin__ = 297;
            current_statement_begin__ = 298;
            current_statement_begin__ = 299;
            check_greater_or_equal(function__,"tau1",tau1,0.0);
            current_statement_begin__ = 300;
            check_greater_or_equal(function__,"tau0",tau0,0.0);
            current_statement_begin__ = 302;
            current_statement_begin__ = 305;
            check_greater_or_equal(function__,"K",K,0.0);
            current_statement_begin__ = 306;
            current_statement_begin__ = 307;
            current_statement_begin__ = 310;
            current_statement_begin__ = 313;
            current_statement_begin__ = 314;
            check_greater_or_equal(function__,"eps",eps,0.0);
            current_statement_begin__ = 315;
            check_greater_or_equal(function__,"scale_signal",scale_signal,0.0);
            current_statement_begin__ = 318;
            check_greater_or_equal(function__,"sig",sig,0.0);

            // model body
            {
            current_statement_begin__ = 352;
            int icon(0);
            (void) icon;  // dummy to suppress unused var warning

            stan::math::fill(icon, std::numeric_limits<int>::min());
            stan::math::assign(icon,0);
            current_statement_begin__ = 353;
            T__ MC_loc;
            (void) MC_loc;  // dummy to suppress unused var warning

            stan::math::initialize(MC_loc, DUMMY_VAR__);
            stan::math::fill(MC_loc,DUMMY_VAR__);


            current_statement_begin__ = 356;
            lp_accum__.add(sample_lpdf<propto__>(tau1_star, tau1_pdf, tau1_p, pstream__));
            current_statement_begin__ = 357;
            lp_accum__.add(sample_lpdf<propto__>(tau0_star, tau1_pdf, tau0_p, pstream__));
            current_statement_begin__ = 359;
            lp_accum__.add(sample_lpdf<propto__>(K_star, K_pdf, K_p, pstream__));
            current_statement_begin__ = 361;
            lp_accum__.add(normal_log<propto__>(MC_split, MC_split_loc, MC_split_scale));
            current_statement_begin__ = 362;
            for (int ii = 1; ii <= n_regions; ++ii) {

                current_statement_begin__ = 363;
                for (int jj = ii; jj <= n_regions; ++jj) {

                    current_statement_begin__ = 364;
                    if (as_bool(logical_eq(ii,jj))) {

                        current_statement_begin__ = 365;
                        lp_accum__.add(normal_log<propto__>(get_base1(MC,ii,jj,"MC",1), 0.0, 0.0));
                    } else {

                        current_statement_begin__ = 367;
                        stan::math::assign(icon, (icon + 1));
                        current_statement_begin__ = 368;
                        stan::math::assign(MC_loc, (get_base1(SC,ii,jj,"SC",1) * get_base1(MC_split,icon,"MC_split",1)));
                        current_statement_begin__ = 369;
                        lp_accum__.add(normal_log<propto__>(get_base1(MC,ii,jj,"MC",1), MC_loc, (MC_loc * MC_scale)));
                        current_statement_begin__ = 370;
                        stan::math::assign(MC_loc, (get_base1(SC,jj,ii,"SC",1) * (1 - get_base1(MC_split,icon,"MC_split",1))));
                        current_statement_begin__ = 371;
                        lp_accum__.add(normal_log<propto__>(get_base1(MC,jj,ii,"MC",1), MC_loc, (MC_loc * MC_scale)));
                    }
                }
            }
            current_statement_begin__ = 375;
            lp_accum__.add(sample_lpdf<propto__>(sig_star, sig_pdf, sig_p, pstream__));
            current_statement_begin__ = 377;
            lp_accum__.add(normal_log<propto__>(x1eq, x1eq0, sig_eq));
            current_statement_begin__ = 378;
            lp_accum__.add(normal_log<propto__>(x1init, x1eq, sig_init));
            current_statement_begin__ = 379;
            lp_accum__.add(normal_log<propto__>(zinit, zeq, (sig_init / 2)));
            current_statement_begin__ = 382;
            lp_accum__.add(sample_lpdf<propto__>(scale_signal_star, scale_signal_pdf, scale_signal_p, pstream__));
            current_statement_begin__ = 383;
            lp_accum__.add(normal_log<propto__>(offset_signal, offset_signal_loc, offset_signal_scale));
            current_statement_begin__ = 385;
            for (int tt = 1; tt <= n_times; ++tt) {

                current_statement_begin__ = 388;
                lp_accum__.add(normal_log<propto__>(to_vector(get_base1(z_dWt,tt,"z_dWt",1)), 0, 1));
            }
            current_statement_begin__ = 391;
            if (as_bool(logical_lte(SIMULATE,0))) {

                current_statement_begin__ = 392;
                for (int tt = 1; tt <= n_times; ++tt) {
                    current_statement_begin__ = 393;
                    lp_accum__.add(normal_log<propto__>(get_base1(signals,tt,"signals",1), get_base1(fit_signals,tt,"fit_signals",1), eps));
                }
            }
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("x1eq");
        names__.push_back("x1init");
        names__.push_back("zinit");
        names__.push_back("z_dWt");
        names__.push_back("tau1_star");
        names__.push_back("tau0_star");
        names__.push_back("K_star");
        names__.push_back("MC_split");
        names__.push_back("MC");
        names__.push_back("sig_star");
        names__.push_back("eps_star");
        names__.push_back("scale_signal_star");
        names__.push_back("offset_signal");
        names__.push_back("x1");
        names__.push_back("z");
        names__.push_back("tau1");
        names__.push_back("tau0");
        names__.push_back("zeq");
        names__.push_back("K");
        names__.push_back("coupling_eq");
        names__.push_back("coupling");
        names__.push_back("x0");
        names__.push_back("fit_signals");
        names__.push_back("eps");
        names__.push_back("scale_signal");
        names__.push_back("sig");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(n_regions);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(n_regions);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(n_regions);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(n_times);
        dims__.push_back(n_active_regions);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(n_connections);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(n_regions);
        dims__.push_back(n_regions);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(n_times);
        dims__.push_back(n_regions);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(n_times);
        dims__.push_back(n_regions);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(n_regions);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(n_regions);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(n_times);
        dims__.push_back(n_regions);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(n_regions);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(n_times);
        dims__.push_back(n_signals);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "vep_sde_model_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        row_vector_d x1eq = in__.row_vector_lub_constrain(x1eq_lo,x1eq_hi,n_regions);
        row_vector_d x1init = in__.row_vector_lub_constrain(x1init_lo,x1init_hi,n_regions);
        row_vector_d zinit = in__.row_vector_lub_constrain(zinit_lo,zinit_hi,n_regions);
        vector<row_vector_d> z_dWt;
        size_t dim_z_dWt_0__ = n_times;
        for (size_t k_0__ = 0; k_0__ < dim_z_dWt_0__; ++k_0__) {
            z_dWt.push_back(in__.row_vector_constrain(n_active_regions));
        }
        double tau1_star = in__.scalar_lub_constrain(tau1_star_lo,tau1_star_hi);
        double tau0_star = in__.scalar_lub_constrain(tau0_star_lo,tau0_star_hi);
        double K_star = in__.scalar_lub_constrain(K_star_lo,K_star_hi);
        row_vector_d MC_split = in__.row_vector_constrain(n_connections);
        matrix_d MC = in__.matrix_lb_constrain(0.0,n_regions,n_regions);
        double sig_star = in__.scalar_lub_constrain(sig_star_lo,sig_star_hi);
        double eps_star = in__.scalar_lub_constrain(eps_star_lo,eps_star_hi);
        double scale_signal_star = in__.scalar_lub_constrain(scale_signal_star_lo,scale_signal_star_hi);
        double offset_signal = in__.scalar_lub_constrain(offset_signal_lo,offset_signal_hi);
            for (int k_0__ = 0; k_0__ < n_regions; ++k_0__) {
            vars__.push_back(x1eq[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < n_regions; ++k_0__) {
            vars__.push_back(x1init[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < n_regions; ++k_0__) {
            vars__.push_back(zinit[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < n_active_regions; ++k_1__) {
                for (int k_0__ = 0; k_0__ < n_times; ++k_0__) {
                vars__.push_back(z_dWt[k_0__][k_1__]);
                }
            }
        vars__.push_back(tau1_star);
        vars__.push_back(tau0_star);
        vars__.push_back(K_star);
            for (int k_0__ = 0; k_0__ < n_connections; ++k_0__) {
            vars__.push_back(MC_split[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < n_regions; ++k_1__) {
                for (int k_0__ = 0; k_0__ < n_regions; ++k_0__) {
                vars__.push_back(MC(k_0__, k_1__));
                }
            }
        vars__.push_back(sig_star);
        vars__.push_back(eps_star);
        vars__.push_back(scale_signal_star);
        vars__.push_back(offset_signal);

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            current_statement_begin__ = 297;
            validate_non_negative_index("x1", "n_regions", n_regions);
            validate_non_negative_index("x1", "n_times", n_times);
            vector<row_vector_d> x1(n_times, (row_vector_d(static_cast<Eigen::VectorXd::Index>(n_regions))));
            stan::math::initialize(x1, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(x1,DUMMY_VAR__);
            current_statement_begin__ = 298;
            validate_non_negative_index("z", "n_regions", n_regions);
            validate_non_negative_index("z", "n_times", n_times);
            vector<row_vector_d> z(n_times, (row_vector_d(static_cast<Eigen::VectorXd::Index>(n_regions))));
            stan::math::initialize(z, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(z,DUMMY_VAR__);
            current_statement_begin__ = 299;
            double tau1(0.0);
            (void) tau1;  // dummy to suppress unused var warning

            stan::math::initialize(tau1, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(tau1,DUMMY_VAR__);
            stan::math::assign(tau1,((tau1_star * tau1_scale) + tau1_loc));
            current_statement_begin__ = 300;
            double tau0(0.0);
            (void) tau0;  // dummy to suppress unused var warning

            stan::math::initialize(tau0, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(tau0,DUMMY_VAR__);
            stan::math::assign(tau0,((tau0_star * tau0_scale) + tau0_loc));
            current_statement_begin__ = 302;
            validate_non_negative_index("zeq", "n_regions", n_regions);
            row_vector_d zeq(static_cast<Eigen::VectorXd::Index>(n_regions));
            (void) zeq;  // dummy to suppress unused var warning

            stan::math::initialize(zeq, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(zeq,DUMMY_VAR__);
            stan::math::assign(zeq,EpileptorDP2D_fun_x1(n_regions,x1eq,zeros,yc,Iext1,a,db,d,slope,1.0, pstream__));
            current_statement_begin__ = 305;
            double K(0.0);
            (void) K;  // dummy to suppress unused var warning

            stan::math::initialize(K, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(K,DUMMY_VAR__);
            stan::math::assign(K,((K_star * K_scale) + K_loc));
            current_statement_begin__ = 306;
            validate_non_negative_index("coupling_eq", "n_regions", n_regions);
            row_vector_d coupling_eq(static_cast<Eigen::VectorXd::Index>(n_regions));
            (void) coupling_eq;  // dummy to suppress unused var warning

            stan::math::initialize(coupling_eq, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(coupling_eq,DUMMY_VAR__);
            stan::math::assign(coupling_eq,calc_coupling(n_regions,n_regions,x1eq,x1eq,MC, pstream__));
            current_statement_begin__ = 307;
            validate_non_negative_index("coupling", "n_regions", n_regions);
            validate_non_negative_index("coupling", "n_times", n_times);
            vector<row_vector_d> coupling(n_times, (row_vector_d(static_cast<Eigen::VectorXd::Index>(n_regions))));
            stan::math::initialize(coupling, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(coupling,DUMMY_VAR__);
            current_statement_begin__ = 310;
            validate_non_negative_index("x0", "n_regions", n_regions);
            row_vector_d x0(static_cast<Eigen::VectorXd::Index>(n_regions));
            (void) x0;  // dummy to suppress unused var warning

            stan::math::initialize(x0, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(x0,DUMMY_VAR__);
            stan::math::assign(x0,divide(EpileptorDP2D_fun_z_lin(n_regions,x1eq,zeq,zeros,multiply(K,coupling_eq),1.0,1.0, pstream__),4.0));
            current_statement_begin__ = 313;
            validate_non_negative_index("fit_signals", "n_signals", n_signals);
            validate_non_negative_index("fit_signals", "n_times", n_times);
            vector<row_vector_d> fit_signals(n_times, (row_vector_d(static_cast<Eigen::VectorXd::Index>(n_signals))));
            stan::math::initialize(fit_signals, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(fit_signals,DUMMY_VAR__);
            current_statement_begin__ = 314;
            double eps(0.0);
            (void) eps;  // dummy to suppress unused var warning

            stan::math::initialize(eps, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(eps,DUMMY_VAR__);
            stan::math::assign(eps,((eps_star * eps_scale) + eps_loc));
            current_statement_begin__ = 315;
            double scale_signal(0.0);
            (void) scale_signal;  // dummy to suppress unused var warning

            stan::math::initialize(scale_signal, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(scale_signal,DUMMY_VAR__);
            stan::math::assign(scale_signal,((scale_signal_star * scale_signal_scale) + scale_signal_loc));
            current_statement_begin__ = 318;
            double sig(0.0);
            (void) sig;  // dummy to suppress unused var warning

            stan::math::initialize(sig, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(sig,DUMMY_VAR__);
            stan::math::assign(sig,((sig_star * sig_scale) + sig_loc));


            current_statement_begin__ = 320;
            stan::math::assign(get_base1_lhs(x1,1,"x1",1), x1init);
            current_statement_begin__ = 321;
            stan::math::assign(get_base1_lhs(z,1,"z",1), zinit);
            current_statement_begin__ = 322;
            stan::math::assign(get_base1_lhs(coupling,1,"coupling",1), calc_coupling(n_regions,n_regions,get_base1(x1,1,"x1",1),get_base1(x1,1,"x1",1),MC, pstream__));
            {
            current_statement_begin__ = 324;
            validate_non_negative_index("df", "n_regions", n_regions);
            row_vector_d df(static_cast<Eigen::VectorXd::Index>(n_regions));
            (void) df;  // dummy to suppress unused var warning

            stan::math::initialize(df, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(df,DUMMY_VAR__);
            current_statement_begin__ = 325;
            validate_non_negative_index("observation", "n_regions", n_regions);
            row_vector_d observation(static_cast<Eigen::VectorXd::Index>(n_regions));
            (void) observation;  // dummy to suppress unused var warning

            stan::math::initialize(observation, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(observation,DUMMY_VAR__);


            current_statement_begin__ = 327;
            for (int tt = 2; tt <= n_times; ++tt) {

                current_statement_begin__ = 328;
                stan::math::assign(df, EpileptorDP2D_fun_x1(n_regions,get_base1(x1,(tt - 1),"x1",1),get_base1(z,(tt - 1),"z",1),yc,Iext1,a,db,d,slope,tau1, pstream__));
                current_statement_begin__ = 329;
                stan::math::assign(get_base1_lhs(x1,tt,"x1",1), ode_step(n_regions,get_base1(x1,(tt - 1),"x1",1),df,dt, pstream__));
                current_statement_begin__ = 330;
                stan::math::assign(get_base1_lhs(coupling,tt,"coupling",1), calc_coupling(n_regions,n_regions,get_base1(x1,tt,"x1",1),get_base1(x1,tt,"x1",1),MC, pstream__));
                current_statement_begin__ = 331;
                stan::math::assign(df, EpileptorDP2D_fun_z_lin(n_regions,get_base1(x1,(tt - 1),"x1",1),get_base1(z,(tt - 1),"z",1),x0,multiply(K,get_base1(coupling,(tt - 1),"coupling",1)),tau0,tau1, pstream__));
                current_statement_begin__ = 332;
                stan::model::assign(z, 
                            stan::model::cons_list(stan::model::index_uni(tt), stan::model::cons_list(stan::model::index_multi(active_regions), stan::model::nil_index_list())), 
                            stan::model::deep_copy(sde_step(n_regions,stan::model::rvalue(z, stan::model::cons_list(stan::model::index_uni((tt - 1)), stan::model::cons_list(stan::model::index_multi(active_regions), stan::model::nil_index_list())), "z"),df,dt,multiply(get_base1(z_dWt,(tt - 1),"z_dWt",1),sqrtdt), pstream__)), 
                            "assigning variable z");
                current_statement_begin__ = 333;
                stan::model::assign(z, 
                            stan::model::cons_list(stan::model::index_uni(tt), stan::model::cons_list(stan::model::index_multi(nonactive_regions), stan::model::nil_index_list())), 
                            stan::model::deep_copy(ode_step(n_regions,stan::model::rvalue(z, stan::model::cons_list(stan::model::index_uni((tt - 1)), stan::model::cons_list(stan::model::index_multi(active_regions), stan::model::nil_index_list())), "z"),df,dt, pstream__)), 
                            "assigning variable z");
                current_statement_begin__ = 335;
                if (as_bool(logical_eq(observation_model,0))) {

                    current_statement_begin__ = 337;
                    stan::math::assign(get_base1_lhs(fit_signals,tt,"fit_signals",1), transpose(add(multiply(scale_signal,log(multiply(mixing,exp(transpose(get_base1(x1,tt,"x1",1)))))),offset_signal)));
                } else if (as_bool(logical_eq(observation_model,1))) {

                    current_statement_begin__ = 340;
                    stan::math::assign(get_base1_lhs(fit_signals,tt,"fit_signals",1), transpose(add(multiply(multiply(scale_signal,mixing),transpose(get_base1(x1,tt,"x1",1))),offset_signal)));
                } else {

                    current_statement_begin__ = 343;
                    stan::math::assign(get_base1_lhs(fit_signals,tt,"fit_signals",1), add(multiply(scale_signal,get_base1(x1,tt,"x1",1)),offset_signal));
                }
            }
            }

            // validate transformed parameters
            current_statement_begin__ = 297;
            current_statement_begin__ = 298;
            current_statement_begin__ = 299;
            check_greater_or_equal(function__,"tau1",tau1,0.0);
            current_statement_begin__ = 300;
            check_greater_or_equal(function__,"tau0",tau0,0.0);
            current_statement_begin__ = 302;
            current_statement_begin__ = 305;
            check_greater_or_equal(function__,"K",K,0.0);
            current_statement_begin__ = 306;
            current_statement_begin__ = 307;
            current_statement_begin__ = 310;
            current_statement_begin__ = 313;
            current_statement_begin__ = 314;
            check_greater_or_equal(function__,"eps",eps,0.0);
            current_statement_begin__ = 315;
            check_greater_or_equal(function__,"scale_signal",scale_signal,0.0);
            current_statement_begin__ = 318;
            check_greater_or_equal(function__,"sig",sig,0.0);

            // write transformed parameters
            for (int k_1__ = 0; k_1__ < n_regions; ++k_1__) {
                for (int k_0__ = 0; k_0__ < n_times; ++k_0__) {
                vars__.push_back(x1[k_0__][k_1__]);
                }
            }
            for (int k_1__ = 0; k_1__ < n_regions; ++k_1__) {
                for (int k_0__ = 0; k_0__ < n_times; ++k_0__) {
                vars__.push_back(z[k_0__][k_1__]);
                }
            }
        vars__.push_back(tau1);
        vars__.push_back(tau0);
            for (int k_0__ = 0; k_0__ < n_regions; ++k_0__) {
            vars__.push_back(zeq[k_0__]);
            }
        vars__.push_back(K);
            for (int k_0__ = 0; k_0__ < n_regions; ++k_0__) {
            vars__.push_back(coupling_eq[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < n_regions; ++k_1__) {
                for (int k_0__ = 0; k_0__ < n_times; ++k_0__) {
                vars__.push_back(coupling[k_0__][k_1__]);
                }
            }
            for (int k_0__ = 0; k_0__ < n_regions; ++k_0__) {
            vars__.push_back(x0[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < n_signals; ++k_1__) {
                for (int k_0__ = 0; k_0__ < n_times; ++k_0__) {
                vars__.push_back(fit_signals[k_0__][k_1__]);
                }
            }
        vars__.push_back(eps);
        vars__.push_back(scale_signal);
        vars__.push_back(sig);

            if (!include_gqs__) return;
            // declare and define generated quantities



            // validate generated quantities

            // write generated quantities
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "vep_sde_model";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= n_regions; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "x1eq" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= n_regions; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "x1init" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= n_regions; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "zinit" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= n_active_regions; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= n_times; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "z_dWt" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "tau1_star";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "tau0_star";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "K_star";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= n_connections; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "MC_split" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= n_regions; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= n_regions; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "MC" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "sig_star";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "eps_star";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "scale_signal_star";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "offset_signal";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_1__ = 1; k_1__ <= n_regions; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= n_times; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "x1" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= n_regions; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= n_times; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "z" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "tau1";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "tau0";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= n_regions; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "zeq" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "K";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= n_regions; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "coupling_eq" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= n_regions; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= n_times; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "coupling" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_0__ = 1; k_0__ <= n_regions; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "x0" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= n_signals; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= n_times; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "fit_signals" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "eps";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "scale_signal";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "sig";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__) return;
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= n_regions; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "x1eq" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= n_regions; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "x1init" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= n_regions; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "zinit" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= n_active_regions; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= n_times; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "z_dWt" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "tau1_star";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "tau0_star";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "K_star";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= n_connections; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "MC_split" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= n_regions; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= n_regions; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "MC" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "sig_star";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "eps_star";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "scale_signal_star";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "offset_signal";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_1__ = 1; k_1__ <= n_regions; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= n_times; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "x1" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_1__ = 1; k_1__ <= n_regions; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= n_times; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "z" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "tau1";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "tau0";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= n_regions; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "zeq" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "K";
        param_names__.push_back(param_name_stream__.str());
        for (int k_0__ = 1; k_0__ <= n_regions; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "coupling_eq" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= n_regions; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= n_times; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "coupling" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_0__ = 1; k_0__ <= n_regions; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "x0" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= n_signals; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= n_times; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "fit_signals" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "eps";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "scale_signal";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "sig";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__) return;
    }

}; // model

}

typedef vep_sde_model_namespace::vep_sde_model stan_model;

